# Comparing `tmp/nanobind-1.3.2-py3-none-any.whl.zip` & `tmp/nanobind-1.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,77 +1,77 @@
-Zip file size: 177183 bytes, number of entries: 75
--rw-r--r--  2.0 unx      536 b- defN 23-Jun-02 14:46 nanobind/__init__.py
--rw-r--r--  2.0 unx      839 b- defN 23-May-31 11:54 nanobind/__main__.py
--rw-r--r--  2.0 unx    21457 b- defN 23-May-31 11:54 nanobind/cmake/darwin-ld-cpython.sym
--rw-r--r--  2.0 unx    24614 b- defN 23-Jun-01 13:24 nanobind/cmake/darwin-ld-pypy.sym
--rw-r--r--  2.0 unx    10761 b- defN 23-Jun-02 14:38 nanobind/cmake/nanobind-config.cmake
--rw-r--r--  2.0 unx    11776 b- defN 23-May-31 11:54 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h
--rw-r--r--  2.0 unx    54550 b- defN 23-May-31 11:54 nanobind/ext/robin_map/include/tsl/robin_hash.h
--rw-r--r--  2.0 unx    28414 b- defN 23-May-31 11:54 nanobind/ext/robin_map/include/tsl/robin_map.h
--rw-r--r--  2.0 unx    23593 b- defN 23-May-31 11:54 nanobind/ext/robin_map/include/tsl/robin_set.h
--rw-r--r--  2.0 unx     5601 b- defN 23-May-31 11:54 nanobind/include/nanobind/make_iterator.h
--rw-r--r--  2.0 unx     1628 b- defN 23-Jun-02 14:46 nanobind/include/nanobind/nanobind.h
--rw-r--r--  2.0 unx     5626 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_accessor.h
--rw-r--r--  2.0 unx     7387 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_attr.h
--rw-r--r--  2.0 unx     5533 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_call.h
--rw-r--r--  2.0 unx    14781 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_cast.h
--rw-r--r--  2.0 unx    23845 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_class.h
--rw-r--r--  2.0 unx     5558 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_defs.h
--rw-r--r--  2.0 unx     4129 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_descr.h
--rw-r--r--  2.0 unx      666 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_enums.h
--rw-r--r--  2.0 unx     4168 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_error.h
--rw-r--r--  2.0 unx     9769 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_func.h
--rw-r--r--  2.0 unx    18829 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_lib.h
--rw-r--r--  2.0 unx     1167 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_misc.h
--rw-r--r--  2.0 unx     1377 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_python.h
--rw-r--r--  2.0 unx     6653 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_traits.h
--rw-r--r--  2.0 unx     2468 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_tuple.h
--rw-r--r--  2.0 unx    25243 b- defN 23-May-31 11:54 nanobind/include/nanobind/nb_types.h
--rw-r--r--  2.0 unx    13478 b- defN 23-May-31 11:54 nanobind/include/nanobind/ndarray.h
--rw-r--r--  2.0 unx     7449 b- defN 23-May-31 11:54 nanobind/include/nanobind/operators.h
--rw-r--r--  2.0 unx     2851 b- defN 23-May-31 11:54 nanobind/include/nanobind/trampoline.h
--rw-r--r--  2.0 unx     8579 b- defN 23-May-31 11:54 nanobind/include/nanobind/eigen/dense.h
--rw-r--r--  2.0 unx     6486 b- defN 23-May-31 11:54 nanobind/include/nanobind/eigen/sparse.h
--rw-r--r--  2.0 unx      535 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/array.h
--rw-r--r--  2.0 unx     5775 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/bind_map.h
--rw-r--r--  2.0 unx     7250 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/bind_vector.h
--rw-r--r--  2.0 unx     8675 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/chrono.h
--rw-r--r--  2.0 unx     2720 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/filesystem.h
--rw-r--r--  2.0 unx     2478 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/function.h
--rw-r--r--  2.0 unx      527 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/list.h
--rw-r--r--  2.0 unx      596 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/map.h
--rw-r--r--  2.0 unx     2281 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/optional.h
--rw-r--r--  2.0 unx     3403 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/pair.h
--rw-r--r--  2.0 unx      575 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/set.h
--rw-r--r--  2.0 unx     5022 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/shared_ptr.h
--rw-r--r--  2.0 unx     1019 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/string.h
--rw-r--r--  2.0 unx     1063 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/string_view.h
--rw-r--r--  2.0 unx     3463 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/tuple.h
--rw-r--r--  2.0 unx     4310 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/unique_ptr.h
--rw-r--r--  2.0 unx      646 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/unordered_map.h
--rw-r--r--  2.0 unx      652 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/unordered_set.h
--rw-r--r--  2.0 unx     3386 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/variant.h
--rw-r--r--  2.0 unx      537 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/vector.h
--rw-r--r--  2.0 unx    10571 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/detail/chrono.h
--rw-r--r--  2.0 unx     1680 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/detail/nb_array.h
--rw-r--r--  2.0 unx     2655 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/detail/nb_dict.h
--rw-r--r--  2.0 unx     2132 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/detail/nb_list.h
--rw-r--r--  2.0 unx     1942 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/detail/nb_set.h
--rw-r--r--  2.0 unx     3218 b- defN 23-May-31 11:54 nanobind/include/nanobind/stl/detail/traits.h
--rw-r--r--  2.0 unx     4218 b- defN 23-May-31 11:54 nanobind/src/buffer.h
--rw-r--r--  2.0 unx    28423 b- defN 23-Jun-01 13:23 nanobind/src/common.cpp
--rw-r--r--  2.0 unx     5671 b- defN 23-May-31 11:54 nanobind/src/error.cpp
--rw-r--r--  2.0 unx     2548 b- defN 23-May-31 11:54 nanobind/src/implicit.cpp
--rw-r--r--  2.0 unx    14696 b- defN 23-Jun-02 14:38 nanobind/src/nb_enum.cpp
--rw-r--r--  2.0 unx    41402 b- defN 23-May-31 11:54 nanobind/src/nb_func.cpp
--rw-r--r--  2.0 unx    14833 b- defN 23-May-31 11:54 nanobind/src/nb_internals.cpp
--rw-r--r--  2.0 unx    10036 b- defN 23-Jun-02 14:38 nanobind/src/nb_internals.h
--rw-r--r--  2.0 unx    21192 b- defN 23-Jun-02 14:38 nanobind/src/nb_ndarray.cpp
--rw-r--r--  2.0 unx     2466 b- defN 23-May-31 11:54 nanobind/src/nb_static_property.cpp
--rw-r--r--  2.0 unx    52907 b- defN 23-May-31 11:54 nanobind/src/nb_type.cpp
--rw-r--r--  2.0 unx     3796 b- defN 23-May-31 11:54 nanobind/src/trampoline.cpp
--rw-r--r--  2.0 unx     1521 b- defN 23-Jun-02 14:47 nanobind-1.3.2.dist-info/LICENSE
--rw-r--r--  2.0 unx     1406 b- defN 23-Jun-02 14:47 nanobind-1.3.2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-02 14:47 nanobind-1.3.2.dist-info/WHEEL
--rw-r--r--  2.0 unx        9 b- defN 23-Jun-02 14:47 nanobind-1.3.2.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6942 b- defN 23-Jun-02 14:47 nanobind-1.3.2.dist-info/RECORD
-75 files, 649080 bytes uncompressed, 166029 bytes compressed:  74.4%
+Zip file size: 179998 bytes, number of entries: 75
+-rw-r--r--  2.0 unx      536 b- defN 23-Jun-08 06:57 nanobind/__init__.py
+-rw-r--r--  2.0 unx      839 b- defN 23-Jun-08 06:57 nanobind/__main__.py
+-rw-r--r--  2.0 unx    21457 b- defN 23-Jun-08 06:57 nanobind/cmake/darwin-ld-cpython.sym
+-rw-r--r--  2.0 unx    24614 b- defN 23-Jun-08 06:57 nanobind/cmake/darwin-ld-pypy.sym
+-rw-r--r--  2.0 unx    11539 b- defN 23-Jun-08 06:57 nanobind/cmake/nanobind-config.cmake
+-rw-r--r--  2.0 unx    11776 b- defN 23-Jun-08 06:57 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h
+-rw-r--r--  2.0 unx    54550 b- defN 23-Jun-08 06:57 nanobind/ext/robin_map/include/tsl/robin_hash.h
+-rw-r--r--  2.0 unx    28414 b- defN 23-Jun-08 06:57 nanobind/ext/robin_map/include/tsl/robin_map.h
+-rw-r--r--  2.0 unx    23593 b- defN 23-Jun-08 06:57 nanobind/ext/robin_map/include/tsl/robin_set.h
+-rw-r--r--  2.0 unx     5601 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/make_iterator.h
+-rw-r--r--  2.0 unx     1628 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nanobind.h
+-rw-r--r--  2.0 unx     5626 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_accessor.h
+-rw-r--r--  2.0 unx     7387 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_attr.h
+-rw-r--r--  2.0 unx     5533 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_call.h
+-rw-r--r--  2.0 unx    14781 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_cast.h
+-rw-r--r--  2.0 unx    23613 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_class.h
+-rw-r--r--  2.0 unx     5755 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_defs.h
+-rw-r--r--  2.0 unx     4129 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_descr.h
+-rw-r--r--  2.0 unx      666 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_enums.h
+-rw-r--r--  2.0 unx     4168 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_error.h
+-rw-r--r--  2.0 unx     9769 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_func.h
+-rw-r--r--  2.0 unx    18946 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_lib.h
+-rw-r--r--  2.0 unx     1167 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_misc.h
+-rw-r--r--  2.0 unx     1377 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_python.h
+-rw-r--r--  2.0 unx     6653 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_traits.h
+-rw-r--r--  2.0 unx     2468 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_tuple.h
+-rw-r--r--  2.0 unx    25243 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_types.h
+-rw-r--r--  2.0 unx    13617 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/ndarray.h
+-rw-r--r--  2.0 unx     7449 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/operators.h
+-rw-r--r--  2.0 unx     2976 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/trampoline.h
+-rw-r--r--  2.0 unx    17102 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/eigen/dense.h
+-rw-r--r--  2.0 unx     6486 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/eigen/sparse.h
+-rw-r--r--  2.0 unx      535 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/array.h
+-rw-r--r--  2.0 unx     5939 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/bind_map.h
+-rw-r--r--  2.0 unx     7420 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/bind_vector.h
+-rw-r--r--  2.0 unx     8675 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/chrono.h
+-rw-r--r--  2.0 unx     2720 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/filesystem.h
+-rw-r--r--  2.0 unx     2478 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/function.h
+-rw-r--r--  2.0 unx      527 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/list.h
+-rw-r--r--  2.0 unx      596 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/map.h
+-rw-r--r--  2.0 unx     2281 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/optional.h
+-rw-r--r--  2.0 unx     3403 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/pair.h
+-rw-r--r--  2.0 unx      575 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/set.h
+-rw-r--r--  2.0 unx     5022 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/shared_ptr.h
+-rw-r--r--  2.0 unx     1019 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/string.h
+-rw-r--r--  2.0 unx     1063 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/string_view.h
+-rw-r--r--  2.0 unx     3463 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/tuple.h
+-rw-r--r--  2.0 unx     4310 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/unique_ptr.h
+-rw-r--r--  2.0 unx      646 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/unordered_map.h
+-rw-r--r--  2.0 unx      652 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/unordered_set.h
+-rw-r--r--  2.0 unx     3386 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/variant.h
+-rw-r--r--  2.0 unx      537 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/vector.h
+-rw-r--r--  2.0 unx    10571 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/detail/chrono.h
+-rw-r--r--  2.0 unx     1680 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/detail/nb_array.h
+-rw-r--r--  2.0 unx     2655 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/detail/nb_dict.h
+-rw-r--r--  2.0 unx     2132 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/detail/nb_list.h
+-rw-r--r--  2.0 unx     1942 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/detail/nb_set.h
+-rw-r--r--  2.0 unx     3218 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/detail/traits.h
+-rw-r--r--  2.0 unx     4218 b- defN 23-Jun-08 06:57 nanobind/src/buffer.h
+-rw-r--r--  2.0 unx    28362 b- defN 23-Jun-08 06:57 nanobind/src/common.cpp
+-rw-r--r--  2.0 unx     5624 b- defN 23-Jun-08 06:57 nanobind/src/error.cpp
+-rw-r--r--  2.0 unx     2538 b- defN 23-Jun-08 06:57 nanobind/src/implicit.cpp
+-rw-r--r--  2.0 unx    14696 b- defN 23-Jun-08 06:57 nanobind/src/nb_enum.cpp
+-rw-r--r--  2.0 unx    39358 b- defN 23-Jun-08 06:57 nanobind/src/nb_func.cpp
+-rw-r--r--  2.0 unx    14972 b- defN 23-Jun-08 06:57 nanobind/src/nb_internals.cpp
+-rw-r--r--  2.0 unx     9801 b- defN 23-Jun-08 06:57 nanobind/src/nb_internals.h
+-rw-r--r--  2.0 unx    21147 b- defN 23-Jun-08 06:57 nanobind/src/nb_ndarray.cpp
+-rw-r--r--  2.0 unx     2348 b- defN 23-Jun-08 06:57 nanobind/src/nb_static_property.cpp
+-rw-r--r--  2.0 unx    52719 b- defN 23-Jun-08 06:57 nanobind/src/nb_type.cpp
+-rw-r--r--  2.0 unx     5144 b- defN 23-Jun-08 06:57 nanobind/src/trampoline.cpp
+-rw-r--r--  2.0 unx     1521 b- defN 23-Jun-08 06:57 nanobind-1.4.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1406 b- defN 23-Jun-08 06:57 nanobind-1.4.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-08 06:57 nanobind-1.4.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        9 b- defN 23-Jun-08 06:57 nanobind-1.4.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6942 b- defN 23-Jun-08 06:57 nanobind-1.4.0.dist-info/RECORD
+75 files, 657800 bytes uncompressed, 168844 bytes compressed:  74.3%
```

## zipnote {}

```diff
@@ -204,23 +204,23 @@
 
 Filename: nanobind/src/nb_type.cpp
 Comment: 
 
 Filename: nanobind/src/trampoline.cpp
 Comment: 
 
-Filename: nanobind-1.3.2.dist-info/LICENSE
+Filename: nanobind-1.4.0.dist-info/LICENSE
 Comment: 
 
-Filename: nanobind-1.3.2.dist-info/METADATA
+Filename: nanobind-1.4.0.dist-info/METADATA
 Comment: 
 
-Filename: nanobind-1.3.2.dist-info/WHEEL
+Filename: nanobind-1.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: nanobind-1.3.2.dist-info/top_level.txt
+Filename: nanobind-1.4.0.dist-info/top_level.txt
 Comment: 
 
-Filename: nanobind-1.3.2.dist-info/RECORD
+Filename: nanobind-1.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## nanobind/__init__.py

```diff
@@ -8,14 +8,14 @@
     "Return the path to the nanobind include directory"
     return os.path.join(os.path.abspath(os.path.dirname(__file__)), "include")
 
 def cmake_dir() -> str:
     "Return the path to the nanobind CMake module directory."
     return os.path.join(os.path.abspath(os.path.dirname(__file__)), "cmake")
 
-__version__ = "1.3.2"
+__version__ = "1.4.0"
 
 __all__ = (
     "__version__",
     "include_dir",
     "cmake_dir",
 )
```

## nanobind/cmake/nanobind-config.cmake

```diff
@@ -1,49 +1,65 @@
 include_guard(GLOBAL)
 
 if (NOT TARGET Python::Module)
   message(FATAL_ERROR "You must invoke 'find_package(Python COMPONENTS Interpreter Development REQUIRED)' prior to including nanobind.")
 endif()
 
 # Determine the right suffix for ordinary and stable ABI extensions.
-# Python_SOSABI is guaranteed to be available in CMake 3.26+, and it may
-# also be available as part of backported FindPython in scikit-build-core
-if (DEFINED Python_SOSABI)
-  if (WIN32)
-    set(NB_SUFFIX_EXT ".pyd")
-  else()
-    set(NB_SUFFIX_EXT "${CMAKE_SHARED_MODULE_SUFFIX}")
-  endif()
 
-  set(NB_SUFFIX   ".${Python_SOABI}${NB_SUFFIX_EXT}")
+# We always need to know the extension
+if(WIN32)
+  set(NB_SUFFIX_EXT ".pyd")
+else()
+  set(NB_SUFFIX_EXT "${CMAKE_SHARED_MODULE_SUFFIX}")
+endif()
+
+# This was added in CMake 3.17+, also available earlier in scikit-build-core.
+# PyPy sets an invalid SOABI (platform missing), causing older FindPythons to
+# report an incorrect value. Only use it if it looks correct (X-X-X form).
+if(DEFINED Python_SOABI AND "${Python_SOABI}" MATCHES ".+-.+-.+")
+  set(NB_SUFFIX ".${Python_SOABI}${NB_SUFFIX_EXT}")
+endif()
 
-  if (Python_SOSABI STREQUAL "")
+# Python_SOSABI is guaranteed to be available in CMake 3.26+, and it may
+# also be available as part of backported FindPython in scikit-build-core.
+if(DEFINED Python_SOSABI)
+  if(Python_SOSABI STREQUAL "")
     set(NB_SUFFIX_S "${NB_SUFFIX_EXT}")
   else()
     set(NB_SUFFIX_S ".${Python_SOSABI}${NB_SUFFIX_EXT}")
   endif()
-else()
-  # Query Python directly to get the right suffix
+endif()
+
+# If either suffix is missing, call Python to compute it
+if(NOT DEFINED NB_SUFFIX OR NOT DEFINED NB_SUFFIX_S)
+  # Query Python directly to get the right suffix.
   execute_process(
     COMMAND "${Python_EXECUTABLE}" "-c"
       "import sysconfig; print(sysconfig.get_config_var('EXT_SUFFIX'))"
     RESULT_VARIABLE NB_SUFFIX_RET
-    OUTPUT_VARIABLE NB_SUFFIX
+    OUTPUT_VARIABLE EXT_SUFFIX
     OUTPUT_STRIP_TRAILING_WHITESPACE)
 
-  if (NB_SUFFIX_RET AND NOT NB_SUFFIX_RET EQUAL 0)
+  if(NB_SUFFIX_RET AND NOT NB_SUFFIX_RET EQUAL 0)
     message(FATAL_ERROR "nanobind: Python sysconfig query to "
       "find 'EXT_SUFFIX' property failed!")
   endif()
 
-  get_filename_component(NB_SUFFIX_EXT "${NB_SUFFIX}" LAST_EXT)
-  if (WIN32)
-    set(NB_SUFFIX_S "${NB_SUFFIX_EXT}")
-  else()
-    set(NB_SUFFIX_S ".abi3${NB_SUFFIX_EXT}")
+  if(NOT DEFINED NB_SUFFIX)
+    set(NB_SUFFIX "${EXT_SUFFIX}")
+  endif()
+
+  if(NOT DEFINED NB_SUFFIX_S)
+    get_filename_component(NB_SUFFIX_EXT "${EXT_SUFFIX}" LAST_EXT)
+    if(WIN32)
+      set(NB_SUFFIX_S "${NB_SUFFIX_EXT}")
+    else()
+      set(NB_SUFFIX_S ".abi3${NB_SUFFIX_EXT}")
+    endif()
   endif()
 endif()
 
 # Stash these for later use
 set(NB_SUFFIX   ${NB_SUFFIX}   CACHE INTERNAL "")
 set(NB_SUFFIX_S ${NB_SUFFIX_S} CACHE INTERNAL "")
 
@@ -253,15 +269,16 @@
   if ("$ENV{AUDITWHEEL_PLAT}" MATCHES "musllinux")
     target_link_options(${name} PRIVATE -static-libstdc++ -static-libgcc)
   endif()
 endfunction()
 
 function(nanobind_add_module name)
   cmake_parse_arguments(PARSE_ARGV 1 ARG
-    "STABLE_ABI;NB_STATIC;NB_SHARED;PROTECT_STACK;LTO;NOMINSIZE;NOSTRIP;NOTRIM;MUSL_DYNAMIC_LIBCPP" "" "")
+    "STABLE_ABI;NB_STATIC;NB_SHARED;PROTECT_STACK;LTO;NOMINSIZE;NOSTRIP;MUSL_DYNAMIC_LIBCPP"
+    "NB_DOMAIN" "")
 
   add_library(${name} MODULE ${ARG_UNPARSED_ARGUMENTS})
 
   nanobind_compile_options(${name})
   nanobind_link_options(${name})
   set_target_properties(${name} PROPERTIES LINKER_LANGUAGE CXX)
 
@@ -283,16 +300,24 @@
     set(libname "${libname}-static")
   endif()
 
   if (ARG_STABLE_ABI)
     set(libname "${libname}-abi3")
   endif()
 
+  if (ARG_NB_DOMAIN AND ARG_NB_SHARED)
+    set(libname ${libname}-${ARG_NB_DOMAIN})
+  endif()
+
   nanobind_build_library(${libname})
 
+  if (ARG_NB_DOMAIN)
+    target_compile_definitions(${name} PRIVATE NB_DOMAIN=${ARG_NB_DOMAIN})
+  endif()
+
   if (ARG_STABLE_ABI)
     target_compile_definitions(${libname} PUBLIC -DPy_LIMITED_API=0x030C0000)
     nanobind_extension_abi3(${name})
   else()
     nanobind_extension(${name})
   endif()
```

## nanobind/include/nanobind/nanobind.h

```diff
@@ -18,16 +18,16 @@
 #  pragma warning(disable: 4702) // unreachable code (e.g. when binding a noreturn function)
    // The next two lines disable warnings that are "just noise" according to Stephan T. Lavavej (a MSFT STL maintainer)
 #  pragma warning(disable: 4275) // non dll-interface class 'std::exception' used as base for dll-interface class [..]
 #  pragma warning(disable: 4251) // [..] needs to have a dll-interface to be used by clients of class [..]
 #endif
 
 #define NB_VERSION_MAJOR 1
-#define NB_VERSION_MINOR 3
-#define NB_VERSION_PATCH 2
+#define NB_VERSION_MINOR 4
+#define NB_VERSION_PATCH 0
 
 // Core C++ headers that nanobind depends on
 #include <cstdint>
 #include <exception>
 #include <stdexcept>
 #include <type_traits>
 #include <typeinfo>
```

## nanobind/include/nanobind/nb_class.h

```diff
@@ -41,22 +41,19 @@
 
     /// Instances of this type support dynamic attribute assignment
     has_dynamic_attr         = (1 << 10),
 
     /// The class uses an intrusive reference counting approach
     intrusive_ptr            = (1 << 11),
 
-    /// Is this a trampoline class meant to be overloaded in Python?
-    is_trampoline            = (1 << 12),
-
     /// Is this a class that inherits from enable_shared_from_this?
     /// If so, type_data::keep_shared_from_this_alive is also set.
-    has_shared_from_this     = (1 << 13),
+    has_shared_from_this     = (1 << 12),
 
-    // Five more flag bits available (14 through 18) without needing
+    // Six more flag bits available (13 through 18) without needing
     // a larger reorganization
 };
 
 /// Flags about a type that are only relevant when it is being created.
 /// These are currently stored in type_data::flags alongside the type_flags
 /// for more efficient memory layout, but could move elsewhere if we run
 /// out of flags.
@@ -357,17 +354,14 @@
         d.type = &typeid(T);
 
         if constexpr (!std::is_same_v<Base, T>) {
             d.base = &typeid(Base);
             d.flags |= (uint32_t) detail::type_init_flags::has_base;
         }
 
-        if constexpr (!std::is_same_v<Alias, T>)
-            d.flags |= (uint32_t) detail::type_flags::is_trampoline;
-
         if constexpr (detail::is_copy_constructible_v<T>) {
             d.flags |= (uint32_t) detail::type_flags::is_copy_constructible;
 
             if constexpr (!std::is_trivially_copy_constructible_v<T>) {
                 d.flags |= (uint32_t) detail::type_flags::has_copy;
                 d.copy = detail::wrap_copy<T>;
             }
```

## nanobind/include/nanobind/nb_defs.h

```diff
@@ -129,23 +129,30 @@
 #  define NB_DICT_GET_SIZE PyDict_GET_SIZE
 #endif
 
 #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x07030a00
 #    error "nanobind requires a newer PyPy version (>= 7.3.10)"
 #endif
 
+#if defined(NB_DOMAIN)
+#  define NB_DOMAIN_STR NB_TOSTRING(NB_DOMAIN)
+#else
+#  define NB_DOMAIN_STR nullptr
+#endif
+
 #define NB_MODULE_IMPL(name)                                                   \
     extern "C" [[maybe_unused]] NB_EXPORT PyObject *PyInit_##name();           \
     extern "C" NB_EXPORT PyObject *PyInit_##name()
 
 #define NB_MODULE(name, variable)                                              \
     static PyModuleDef NB_CONCAT(nanobind_module_def_, name);                  \
     [[maybe_unused]] static void NB_CONCAT(nanobind_init_,                     \
                                            name)(::nanobind::module_ &);       \
     NB_MODULE_IMPL(name) {                                                     \
+        nanobind::detail::init(NB_DOMAIN_STR);                                 \
         nanobind::module_ m =                                                  \
             nanobind::steal<nanobind::module_>(nanobind::detail::module_new(   \
                 NB_TOSTRING(name), &NB_CONCAT(nanobind_module_def_, name)));   \
         try {                                                                  \
             NB_CONCAT(nanobind_init_, name)(m);                                \
             return m.release().ptr();                                          \
         } catch (const std::exception &e) {                                    \
```

## nanobind/include/nanobind/nb_lib.h

```diff
@@ -86,14 +86,18 @@
 NB_CORE void raise_next_overload_if_null(void *p);
 
 /// Raise nanobind::cast_error
 NB_CORE void raise_cast_error();
 
 // ========================================================================
 
+NB_CORE void init(const char *domain);
+
+// ========================================================================
+
 /// Convert a Python object into a Python unicode string
 NB_CORE PyObject *str_from_obj(PyObject *o);
 
 /// Convert an UTF8 null-terminated C string into a Python unicode string
 NB_CORE PyObject *str_from_cstr(const char *c);
 
 /// Convert an UTF8 C string + size into a Python unicode string
```

## nanobind/include/nanobind/ndarray.h

```diff
@@ -74,17 +74,24 @@
 struct f_contig { };
 struct any_contig { };
 struct numpy { };
 struct tensorflow { };
 struct pytorch { };
 struct jax { };
 
+NAMESPACE_BEGIN(detail)
+
+template<typename T> constexpr bool is_ndarray_scalar_v =
+std::is_floating_point_v<T> || std::is_integral_v<T>;
+
+NAMESPACE_END(detail)
+
 template <typename T> constexpr dlpack::dtype dtype() {
     static_assert(
-        std::is_floating_point_v<T> || std::is_integral_v<T>,
+        detail::is_ndarray_scalar_v<T>,
         "nanobind::dtype<T>: T must be a floating point or integer variable!"
     );
 
     dlpack::dtype result;
 
     if constexpr (std::is_floating_point_v<T>)
         result.code = (uint8_t) dlpack::dtype_code::Float;
```

## nanobind/include/nanobind/trampoline.h

```diff
@@ -11,57 +11,65 @@
 #pragma once
 
 #include <nanobind/nanobind.h>
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
+struct ticket;
+
 NB_CORE void trampoline_new(void **data, size_t size, void *ptr) noexcept;
 NB_CORE void trampoline_release(void **data, size_t size) noexcept;
-
-NB_CORE PyObject *trampoline_lookup(void **data, size_t size, const char *name,
-                                    bool pure);
+NB_CORE void trampoline_enter(void **data, size_t size, const char *name,
+                              bool pure, ticket *ticket);
+NB_CORE void trampoline_leave(ticket *ticket) noexcept;
 
 template <size_t Size> struct trampoline {
     mutable void *data[2 * Size + 1];
 
-    NB_INLINE trampoline(void *ptr) {
-        trampoline_new(data, Size, ptr);
-    }
-
+    NB_INLINE trampoline(void *ptr) { trampoline_new(data, Size, ptr); }
     NB_INLINE ~trampoline() { trampoline_release(data, Size); }
 
-    NB_INLINE handle lookup(const char *name, bool pure) const {
-        return trampoline_lookup(data, Size, name, pure);
+    NB_INLINE handle base() const { return (PyObject *) data[0]; }
+};
+
+struct ticket {
+    handle self;
+    handle key;
+    ticket *prev{};
+    PyGILState_STATE state{};
+
+    template <size_t Size>
+    NB_INLINE ticket(const trampoline<Size> &t, const char *name, bool pure) {
+        trampoline_enter(t.data, Size, name, pure, this);
     }
 
-    NB_INLINE handle base() const { return (PyObject *) data[0]; }
+    NB_INLINE ~ticket() noexcept { trampoline_leave(this); }
 };
 
+
 #define NB_TRAMPOLINE(base, size)                                              \
     using NBBase = base;                                                       \
     using NBBase::NBBase;                                                      \
     nanobind::detail::trampoline<size> nb_trampoline{ this }
 
 #define NB_OVERRIDE_NAME(name, func, ...)                                      \
-    nanobind::handle nb_key = nb_trampoline.lookup(name, false);               \
     using nb_ret_type = decltype(NBBase::func(__VA_ARGS__));                   \
-    if (nb_key.is_valid()) {                                                   \
-        nanobind::gil_scoped_acquire nb_guard;                                 \
+    nanobind::detail::ticket nb_ticket(nb_trampoline, name, false);            \
+    if (nb_ticket.key.is_valid()) {                                                       \
         return nanobind::cast<nb_ret_type>(                                    \
-            nb_trampoline.base().attr(nb_key)(__VA_ARGS__));                   \
+            nb_trampoline.base().attr(nb_ticket.key)(__VA_ARGS__));            \
     } else                                                                     \
         return NBBase::func(__VA_ARGS__)
 
 #define NB_OVERRIDE_PURE_NAME(name, func, ...)                                 \
-    nanobind::handle nb_key = nb_trampoline.lookup(name, true);                \
     using nb_ret_type = decltype(NBBase::func(__VA_ARGS__));                   \
-    nanobind::gil_scoped_acquire nb_guard;                                     \
+    nanobind::detail::ticket nb_ticket(nb_trampoline, name, true);             \
     return nanobind::cast<nb_ret_type>(                                        \
-        nb_trampoline.base().attr(nb_key)(__VA_ARGS__))
+        nb_trampoline.base().attr(nb_ticket.key)(__VA_ARGS__))
 
 #define NB_OVERRIDE(func, ...)                                                 \
     NB_OVERRIDE_NAME(#func, func, __VA_ARGS__)
 
 #define NB_OVERRIDE_PURE(func, ...)                                            \
     NB_OVERRIDE_PURE_NAME(#func, func, __VA_ARGS__)
```

## nanobind/include/nanobind/eigen/dense.h

```diff
@@ -14,100 +14,157 @@
 #include <Eigen/Core>
 
 static_assert(EIGEN_VERSION_AT_LEAST(3, 3, 1),
               "Eigen matrix support in nanobind requires Eigen >= 3.3.1");
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 
-/// Types for func. arguments that are compatible with various flavors of arrays
+/// Function argument types that are compatible with various array flavors
 using DStride = Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic>;
 template <typename T> using DRef = Eigen::Ref<T, 0, DStride>;
 template <typename T> using DMap = Eigen::Map<T, 0, DStride>;
 
 NAMESPACE_BEGIN(detail)
 
+/// Determine the number of dimensions of the given Eigen type
 template <typename T>
-constexpr int NumDimensions = bool(T::IsVectorAtCompileTime) ? 1 : 2;
+constexpr int ndim_v = bool(T::IsVectorAtCompileTime) ? 1 : 2;
 
+/// Extract the compile-time strides of the given Eigen type
+template <typename T> struct stride {
+    using type = Eigen::Stride<0, 0>;
+};
+
+template <typename T, int Options, typename StrideType> struct stride<Eigen::Map<T, Options, StrideType>> {
+    using type = StrideType;
+};
+
+template <typename T, int Options, typename StrideType> struct stride<Eigen::Ref<T, Options, StrideType>> {
+    using type = StrideType;
+};
+
+template <typename T> using stride_t = typename stride<T>::type;
+
+/** \brief Identify types with a contiguous memory representation.
+ *
+ * This includes all specializations of ``Eigen::Matrix``/``Eigen::Array`` and
+ * certain specializations of ``Eigen::Map`` and ``Eigen::Ref``. Note: Eigen
+ * interprets a compile-time stride of 0 as contiguous.
+ */
+template <typename T>
+constexpr bool is_contiguous_v =
+    (stride_t<T>::InnerStrideAtCompileTime == 0 ||
+     stride_t<T>::InnerStrideAtCompileTime == 1) &&
+    (ndim_v<T> == 1 || stride_t<T>::OuterStrideAtCompileTime == 0 ||
+     (stride_t<T>::OuterStrideAtCompileTime != Eigen::Dynamic &&
+      stride_t<T>::OuterStrideAtCompileTime == T::InnerSizeAtCompileTime));
+
+/// Identify types with a static or dynamic layout that support contiguous storage
 template <typename T>
+constexpr bool can_map_contiguous_memory_v =
+    (stride_t<T>::InnerStrideAtCompileTime == 0 ||
+     stride_t<T>::InnerStrideAtCompileTime == 1 ||
+     stride_t<T>::InnerStrideAtCompileTime == Eigen::Dynamic) &&
+    (ndim_v<T> == 1 || stride_t<T>::OuterStrideAtCompileTime == 0 ||
+     stride_t<T>::OuterStrideAtCompileTime == Eigen::Dynamic ||
+     stride_t<T>::OuterStrideAtCompileTime == T::InnerSizeAtCompileTime);
+
+/* This type alias builds the most suitable 'ndarray' for the given Eigen type.
+   In particular, it
+
+  - matches the underlying scalar type
+  - matches the number of dimensions (i.e. whether the type is a vector/matrix)
+  - matches the shape (if the row/column count is known at compile time)
+  - matches the in-memory ordering when the Eigen type is contiguous.
+
+  This is helpful because type_caster<ndarray<..>> will then perform the
+  necessary conversion steps (if given incompatible input) to enable data
+  exchange with Eigen.
+
+  A limitation of this approach is that ndarray does not support compile-time
+  strides besides c_contig and f_contig. If an Eigen type requires
+  non-contiguous strides (at compile-time) and we are given an ndarray with
+  unsuitable strides (at run-time), type casting will fail. Note, however, that
+  this is rather unusual, since the default stride type of Eigen::Map requires
+  contiguous memory, and the one of Eigen::Ref requires a contiguous inner
+  stride, while handling any outer stride.
+*/
+
+template <typename T, typename Scalar = typename T::Scalar>
 using array_for_eigen_t = ndarray<
-    typename T::Scalar,
+    Scalar,
     numpy,
     std::conditional_t<
-        NumDimensions<T> == 1,
+        ndim_v<T> == 1,
         shape<(size_t) T::SizeAtCompileTime>,
         shape<(size_t) T::RowsAtCompileTime,
               (size_t) T::ColsAtCompileTime>>,
     std::conditional_t<
-        T::InnerStrideAtCompileTime == Eigen::Dynamic,
-        any_contig,
+        is_contiguous_v<T>,
         std::conditional_t<
-            T::IsRowMajor || NumDimensions<T> == 1,
+            ndim_v<T> == 1 || T::IsRowMajor,
             c_contig,
-            f_contig
-        >
-    >
->;
+            f_contig>,
+        any_contig>>;
 
 /// Any kind of Eigen class
-template <typename T> constexpr bool is_eigen_v =
-is_base_of_template_v<T, Eigen::EigenBase>;
+template <typename T> constexpr bool is_eigen_v = is_base_of_template_v<T, Eigen::EigenBase>;
 
 /// Detects Eigen::Array, Eigen::Matrix, etc.
-template <typename T> constexpr bool is_eigen_plain_v =
-is_base_of_template_v<T, Eigen::PlainObjectBase>;
+template <typename T> constexpr bool is_eigen_plain_v = is_base_of_template_v<T, Eigen::PlainObjectBase>;
 
 /// Detect Eigen::SparseMatrix
-template <typename T> constexpr bool is_eigen_sparse_v =
-is_base_of_template_v<T, Eigen::SparseMatrixBase>;
+template <typename T> constexpr bool is_eigen_sparse_v = is_base_of_template_v<T, Eigen::SparseMatrixBase>;
 
 /// Detects expression templates
 template <typename T> constexpr bool is_eigen_xpr_v =
     is_eigen_v<T> && !is_eigen_plain_v<T> && !is_eigen_sparse_v<T> &&
     !std::is_base_of_v<Eigen::MapBase<T, Eigen::ReadOnlyAccessors>, T>;
 
-template <typename T> struct type_caster<T, enable_if_t<is_eigen_plain_v<T>>> {
+template <typename T>
+struct type_caster<T, enable_if_t<is_eigen_plain_v<T> &&
+                                  is_ndarray_scalar_v<typename T::Scalar>>> {
     using Scalar = typename T::Scalar;
     using NDArray = array_for_eigen_t<T>;
     using NDArrayCaster = make_caster<NDArray>;
 
     NB_TYPE_CASTER(T, NDArrayCaster::Name);
 
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
-        NDArrayCaster caster;
+        // We're in any case making a copy, so non-writable inputs area also okay
+        using NDArrayConst = array_for_eigen_t<T, const typename T::Scalar>;
+        make_caster<NDArrayConst> caster;
         if (!caster.from_python(src, flags, cleanup))
             return false;
-        const NDArray &array = caster.value;
 
-        if constexpr (NumDimensions<T> == 1) {
+        const NDArrayConst &array = caster.value;
+        if constexpr (ndim_v<T> == 1)
             value.resize(array.shape(0));
-            memcpy(value.data(), array.data(),
-                   array.shape(0) * sizeof(Scalar));
-        } else {
+        else
             value.resize(array.shape(0), array.shape(1));
-            memcpy(value.data(), array.data(),
-                   array.shape(0) * array.shape(1) * sizeof(Scalar));
-        }
+
+        // The layout is contiguous & compatible thanks to array_for_eigen_t<T>
+        memcpy(value.data(), array.data(), array.size() * sizeof(Scalar));
 
         return true;
     }
 
     static handle from_cpp(T &&v, rv_policy policy, cleanup_list *cleanup) noexcept {
         if (policy == rv_policy::automatic ||
             policy == rv_policy::automatic_reference)
             policy = rv_policy::move;
 
         return from_cpp((const T &) v, policy, cleanup);
     }
 
     static handle from_cpp(const T &v, rv_policy policy, cleanup_list *cleanup) noexcept {
-        size_t shape[NumDimensions<T>];
-        int64_t strides[NumDimensions<T>];
+        size_t shape[ndim_v<T>];
+        int64_t strides[ndim_v<T>];
 
-        if constexpr (NumDimensions<T> == 1) {
+        if constexpr (ndim_v<T> == 1) {
             shape[0] = v.size();
             strides[0] = v.innerStride();
         } else {
             shape[0] = v.rows();
             shape[1] = v.cols();
             strides[0] = v.rowStride();
             strides[1] = v.colStride();
@@ -144,114 +201,248 @@
             owner = borrow(cleanup->self());
         }
 
         rv_policy array_rv_policy =
             policy == rv_policy::move ? rv_policy::reference : policy;
 
         object o = steal(NDArrayCaster::from_cpp(
-            NDArray(ptr, NumDimensions<T>, shape, owner, strides),
+            NDArray(ptr, ndim_v<T>, shape, owner, strides),
             array_rv_policy, cleanup));
 
         return o.release();
     }
 };
 
 /// Caster for Eigen expression templates
-template <typename T> struct type_caster<T, enable_if_t<is_eigen_xpr_v<T>>> {
+template <typename T>
+struct type_caster<T, enable_if_t<is_eigen_xpr_v<T> &&
+                                  is_ndarray_scalar_v<typename T::Scalar>>> {
     using Array = Eigen::Array<typename T::Scalar, T::RowsAtCompileTime,
                                T::ColsAtCompileTime>;
     using Caster = make_caster<Array>;
+    static constexpr bool IsClass = false;
     static constexpr auto Name = Caster::Name;
     template <typename T_> using Cast = T;
 
     /// Generating an expression template from a Python object is, of course, not possible
     bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept = delete;
 
     template <typename T2>
     static handle from_cpp(T2 &&v, rv_policy policy, cleanup_list *cleanup) noexcept {
         return Caster::from_cpp(std::forward<T2>(v), policy, cleanup);
     }
 };
 
-/// Caster for Eigen::Map<T>
+/** \brief Type caster for ``Eigen::Map<T>``
+
+  The ``Eigen::Map<..>`` type exists to efficiently access memory provided by a
+  caller. Given that, the nanobind type caster refuses to turn incompatible
+  inputs into a ``Eigen::Map<T>`` when this would require an implicit
+  conversion.
+*/
+
 template <typename T, int Options, typename StrideType>
-struct type_caster<Eigen::Map<T, Options, StrideType>, enable_if_t<is_eigen_plain_v<T>>> {
+struct type_caster<Eigen::Map<T, Options, StrideType>,
+                   enable_if_t<is_eigen_plain_v<T> &&
+                               is_ndarray_scalar_v<typename T::Scalar>>> {
     using Map = Eigen::Map<T, Options, StrideType>;
-    using NDArray = array_for_eigen_t<Map>;
+    using NDArray =
+        array_for_eigen_t<Map, std::conditional_t<std::is_const_v<Map>,
+                                                  const typename Map::Scalar,
+                                                  typename Map::Scalar>>;
     using NDArrayCaster = type_caster<NDArray>;
+    static constexpr bool IsClass = false;
     static constexpr auto Name = NDArrayCaster::Name;
     template <typename T_> using Cast = Map;
 
     NDArrayCaster caster;
 
-    bool from_python(handle src, uint8_t flags,
-                     cleanup_list *cleanup) noexcept {
-        return caster.from_python(src, flags, cleanup);
+    bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
+        // Disable implicit conversions
+        return from_python_(src, flags & ~(uint8_t)cast_flags::convert, cleanup);
+    }
+
+    bool from_python_(handle src, uint8_t flags, cleanup_list* cleanup) noexcept {
+        if (!caster.from_python(src, flags, cleanup))
+            return false;
+
+        // Check for memory layout compatibility of non-contiguous 'Map' types
+        if constexpr (!is_contiguous_v<Map>)  {
+            // Dynamic inner strides support any input, check the fixed case
+            if constexpr (StrideType::InnerStrideAtCompileTime != Eigen::Dynamic) {
+                // A compile-time stride of 0 implies "contiguous" ..
+                int64_t is_expected = StrideType::InnerStrideAtCompileTime == 0
+                                      ? 1 /*  .. and equals 1 for the inner stride */
+                                      : StrideType::InnerStrideAtCompileTime,
+                        is_actual = caster.value.stride(
+                            (ndim_v<T> != 1 && T::IsRowMajor) ? 1 : 0);
+
+                if (is_expected != is_actual)
+                    return false;
+            }
+
+            // Analogous check for the outer strides
+            if constexpr (ndim_v<T> == 2 && StrideType::OuterStrideAtCompileTime != Eigen::Dynamic) {
+                int64_t os_expected = StrideType::OuterStrideAtCompileTime == 0
+                                        ? caster.value.shape(T::IsRowMajor ? 1 : 0)
+                                        : StrideType::OuterStrideAtCompileTime,
+                        os_actual   = caster.value.stride(T::IsRowMajor ? 0 : 1);
+
+                if (os_expected != os_actual)
+                    return false;
+            }
+        }
+        return true;
     }
 
     static handle from_cpp(const Map &v, rv_policy, cleanup_list *cleanup) noexcept {
-        size_t shape[NumDimensions<T>];
-        int64_t strides[NumDimensions<T>];
+        size_t shape[ndim_v<T>];
+        int64_t strides[ndim_v<T>];
 
-        if constexpr (NumDimensions<T> == 1) {
+        if constexpr (ndim_v<T> == 1) {
             shape[0] = v.size();
             strides[0] = v.innerStride();
         } else {
             shape[0] = v.rows();
             shape[1] = v.cols();
             strides[0] = v.rowStride();
             strides[1] = v.colStride();
         }
 
         return NDArrayCaster::from_cpp(
-            NDArray((void *) v.data(), NumDimensions<T>, shape, handle(), strides),
+            NDArray((void *) v.data(), ndim_v<T>, shape, handle(), strides),
             rv_policy::reference, cleanup);
     }
 
     StrideType strides() const {
         constexpr int IS = StrideType::InnerStrideAtCompileTime,
                       OS = StrideType::OuterStrideAtCompileTime;
 
         int64_t inner = caster.value.stride(0),
-                outer = caster.value.stride(1);
-        (void) outer;
+                outer;
+        if constexpr (ndim_v<T> == 1)
+            outer = caster.value.shape(0);
+        else
+            outer = caster.value.stride(1);
 
-        if constexpr (T::IsRowMajor)
+        if constexpr (ndim_v<T> == 2 && T::IsRowMajor)
             std::swap(inner, outer);
 
+        // Eigen may expect a stride of 0 to avoid an assertion failure
+        if constexpr (IS == 0)
+            inner = 0;
+
+        if constexpr (OS == 0)
+            outer = 0;
+
         if constexpr (std::is_same_v<StrideType, Eigen::InnerStride<IS>>)
             return StrideType(inner);
         else if constexpr (std::is_same_v<StrideType, Eigen::OuterStride<OS>>)
             return StrideType(outer);
         else
             return StrideType(outer, inner);
     }
 
     operator Map() {
         NDArray &t = caster.value;
-        return Map(t.data(), t.shape(0), t.ndim() == 1 ? 1 : t.shape(1),
-                   strides());
+        if constexpr (ndim_v<T> == 1)
+            return Map(t.data(), t.shape(0), strides());
+        else
+            return Map(t.data(), t.shape(0), t.shape(1), strides());
     }
 };
 
-/// Caster for Eigen::Ref<T>
+/** \brief Caster for Eigen::Ref<T>
+
+  Compared to the ``Eigen::Map<T>`` type caster above, the reference caster
+  accepts a wider set of inputs when it is used in *constant reference* mode
+  (i.e., ``Eigen::Ref<const T>``). In this case, it performs stride conversions
+  (except for unusual non-contiguous strides) as well as conversions of the
+  underlying scalar type (if implicit conversions are enabled).
+
+  For non-constant references, the caster matches that of ``Eigen::Map<T>`` and
+  requires an input with the expected layout (so that changes can propagate to
+  the caller).
+*/
 template <typename T, int Options, typename StrideType>
-struct type_caster<Eigen::Ref<T, Options, StrideType>, enable_if_t<is_eigen_plain_v<T>>> {
+struct type_caster<Eigen::Ref<T, Options, StrideType>,
+                   enable_if_t<is_eigen_plain_v<T> &&
+                               is_ndarray_scalar_v<typename T::Scalar>>> {
     using Ref = Eigen::Ref<T, Options, StrideType>;
+
+    /// Potentially convert strides/dtype when casting constant references
+    static constexpr bool MaybeConvert =
+        std::is_const_v<T> &&
+        // Restrict to contiguous 'T' (limitation in Eigen, see PR #215)
+        can_map_contiguous_memory_v<Ref>;
+
+    /// Eigen::Map<T> caster with fixed strides
     using Map = Eigen::Map<T, Options, StrideType>;
     using MapCaster = make_caster<Map>;
-    static constexpr auto Name = MapCaster::Name;
+
+    // Extended version taking arbitrary strides
+    using DMap = Eigen::Map<const T, Options, DStride>;
+    using DMapCaster = make_caster<DMap>;
+
+    /**
+     * The constructor of ``Ref<const T>`` uses one of two strategies
+     * depending on the input. It may either
+     *
+     * 1. Create a copy ``Ref<const T>::m_object`` (owned by Ref), or
+     * 2. Reference the existing input (non-owned).
+     *
+     * When the value below is ``true``, then it is guaranteed that
+     * ``Ref(<DMap instance>)`` owns the underlying data.
+     */
+    static constexpr bool DMapConstructorOwnsData =
+        !Eigen::internal::traits<Ref>::template match<DMap>::type::value;
+
+    static constexpr bool IsClass = false;
+    static constexpr auto Name =
+        const_name<MaybeConvert>(DMapCaster::Name, MapCaster::Name);
+
     template <typename T_> using Cast = Ref;
 
     MapCaster caster;
+    struct Empty { };
+    std::conditional_t<MaybeConvert, DMapCaster, Empty> dcaster;
+
+    bool from_python(handle src, uint8_t flags, cleanup_list *cleanup) noexcept {
+        // Try a direct cast without implicit conversion first
+        if (caster.from_python(src, flags, cleanup))
+            return true;
+
+        // Potentially convert strides/dtype when casting constant references
+        if constexpr (MaybeConvert) {
+            /* Generating an implicit copy requires some object to assume
+               ownership. During a function call, ``dcaster`` can serve that
+               role (this case is detected by checking whether ``cleanup`` is
+               defined). When used in other situatons (e.g. ``nb::cast()``),
+               the created ``Eigen::Ref<..>`` must take ownership of the copy.
+               This is only guranteed to work if DMapConstructorOwnsData.
+
+               If neither of these is possible, we disable implicit
+               conversions. */
+
+            if (!cleanup && !DMapConstructorOwnsData)
+                flags &= ~(uint8_t) cast_flags::convert;
 
-    bool from_python(handle src, uint8_t flags,
-                     cleanup_list *cleanup) noexcept {
-        return caster.from_python(src, flags, cleanup);
+            if (dcaster.from_python_(src, flags, cleanup))
+                return true;
+        }
+
+        return false;
     }
 
-    operator Ref() { return Ref(caster.operator Map()); }
+    operator Ref() {
+        if constexpr (MaybeConvert) {
+            if (dcaster.caster.value.is_valid())
+                return Ref(dcaster.operator DMap());
+        }
+
+        return Ref(caster.operator Map());
+    }
 };
 
 NAMESPACE_END(detail)
 
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/include/nanobind/stl/bind_map.h

```diff
@@ -38,14 +38,20 @@
 NAMESPACE_END(detail)
 
 template <typename Map, typename... Args>
 class_<Map> bind_map(handle scope, const char *name, Args &&...args) {
     using Key = typename Map::key_type;
     using Value = typename Map::mapped_type;
 
+    handle cl_cur = type<Map>();
+    if (cl_cur.is_valid()) {
+        // Binding already exists, don't re-create
+        return borrow<class_<Map>>(cl_cur);
+    }
+
     auto cl = class_<Map>(scope, name, std::forward<Args>(args)...)
         .def(init<>(),
              "Default constructor")
 
         .def("__len__", [](const Map &m) { return m.size(); })
 
         .def("__bool__",
```

## nanobind/include/nanobind/stl/bind_vector.h

```diff
@@ -44,14 +44,20 @@
 
 
 template <typename Vector, typename... Args>
 class_<Vector> bind_vector(handle scope, const char *name, Args &&...args) {
     using ValueRef = typename detail::iterator_access<typename Vector::iterator>::result_type;
     using Value = std::decay_t<ValueRef>;
 
+    handle cl_cur = type<Vector>();
+    if (cl_cur.is_valid()) {
+        // Binding already exists, don't re-create
+        return borrow<class_<Vector>>(cl_cur);
+    }
+
     auto cl = class_<Vector>(scope, name, std::forward<Args>(args)...)
         .def(init<>(), "Default constructor")
 
         .def("__len__", [](const Vector &v) { return v.size(); })
 
         .def("__bool__",
              [](const Vector &v) { return !v.empty(); },
```

## nanobind/src/common.cpp

```diff
@@ -705,20 +705,19 @@
 }
 
 // ========================================================================
 
 static void property_install_impl(PyTypeObject *tp, PyObject *scope,
                                   const char *name, PyObject *getter,
                                   PyObject *setter) {
-    const nb_internals &internals = internals_get();
     PyObject *m = getter ? getter : setter;
     object doc = none();
 
-    if (m && (Py_TYPE(m) == internals.nb_func ||
-              Py_TYPE(m) == internals.nb_method)) {
+    if (m && (Py_TYPE(m) == internals->nb_func ||
+              Py_TYPE(m) == internals->nb_method)) {
         func_data *f = nb_func_data(m);
         if (f->flags & (uint32_t) func_flags::has_doc)
             doc = str(f->doc);
     }
 
     handle(scope).attr(name) = handle(tp)(
         getter ? handle(getter) : handle(Py_None),
@@ -953,19 +952,19 @@
 #endif
     Py_DECREF(o);
 }
 
 // ========================================================================
 
 void set_leak_warnings(bool value) noexcept {
-    internals_get().print_leak_warnings = value;
+    internals->print_leak_warnings = value;
 }
 
 void set_implicit_cast_warnings(bool value) noexcept {
-    internals_get().print_implicit_cast_warnings = value;
+    internals->print_implicit_cast_warnings = value;
 }
 
 // ========================================================================
 
 void slice_compute(PyObject *slice, Py_ssize_t size, Py_ssize_t &start,
                    Py_ssize_t &stop, Py_ssize_t &step,
                    size_t &slice_length) {
```

## nanobind/src/error.cpp

```diff
@@ -155,17 +155,15 @@
 builtin_exception::builtin_exception(exception_type type, const char *what)
     : std::runtime_error(what ? what : ""), m_type(type) { }
 builtin_exception::~builtin_exception() { }
 
 NAMESPACE_BEGIN(detail)
 
 void register_exception_translator(exception_translator t, void *payload) {
-    nb_internals &internals = internals_get();
-
-    nb_translator_seq *cur  = &internals.translators,
+    nb_translator_seq *cur  = &internals->translators,
                       *next = new nb_translator_seq(*cur);
     cur->next = next;
     cur->payload = payload;
     cur->translator = t;
 }
 
 NB_CORE PyObject *exception_new(PyObject *scope, const char *name,
```

## nanobind/src/implicit.cpp

```diff
@@ -11,15 +11,15 @@
 #include "nb_internals.h"
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 void implicitly_convertible(const std::type_info *src,
                             const std::type_info *dst) noexcept {
-    nb_type_map &type_c2p = internals_get().type_c2p;
+    nb_type_map &type_c2p = internals->type_c2p;
 
     nb_type_map::iterator it = type_c2p.find(std::type_index(*dst));
     check(it != type_c2p.end(),
           "nanobind::detail::implicitly_convertible(src=%s, dst=%s): "
           "destination type unknown!", type_name(src), type_name(dst));
 
     type_data *t = it->second;
@@ -42,15 +42,15 @@
     free(t->implicit);
     t->implicit = (decltype(t->implicit)) data;
 }
 
 void implicitly_convertible(bool (*predicate)(PyTypeObject *, PyObject *,
                                               cleanup_list *),
                             const std::type_info *dst) noexcept {
-    nb_type_map &type_c2p = internals_get().type_c2p;
+    nb_type_map &type_c2p = internals->type_c2p;
 
     nb_type_map::iterator it = type_c2p.find(std::type_index(*dst));
     check(it != type_c2p.end(),
           "nanobind::detail::implicitly_convertible(src=<predicate>, dst=%s): "
           "destination type unknown!", type_name(dst));
 
     type_data *t = it->second;
```

## nanobind/src/nb_func.cpp

```diff
@@ -77,15 +77,15 @@
     PyObject_GC_UnTrack(self);
 
     size_t size = (size_t) Py_SIZE(self);
     if (size) {
         func_data *f = nb_func_data(self);
 
         // Delete from registered function list
-        auto &funcs = internals_get().funcs;
+        auto &funcs = internals->funcs;
         auto it = funcs.find(self);
         check(it != funcs.end(),
               "nanobind::detail::nb_func_dealloc(\"%s\"): function not found!",
               ((f->flags & (uint32_t) func_flags::has_name) ? f->name
                                                             : "<anonymous>"));
         funcs.erase(it);
 
@@ -183,25 +183,24 @@
          is_implicit    = f->flags & (uint32_t) func_flags::is_implicit,
          is_method      = f->flags & (uint32_t) func_flags::is_method,
          return_ref     = f->flags & (uint32_t) func_flags::return_ref,
          is_constructor = false;
 
     PyObject *name = nullptr;
     PyObject *func_prev = nullptr;
-    nb_internals &internals = internals_get();
 
     // Check for previous overloads
     if (has_scope && has_name) {
         name = PyUnicode_FromString(f->name);
         check(name, "nb::detail::nb_func_new(\"%s\"): invalid name.", f->name);
 
         func_prev = PyObject_GetAttr(f->scope, name);
         if (func_prev) {
-            if (Py_TYPE(func_prev) == internals.nb_func ||
-                Py_TYPE(func_prev) == internals.nb_method) {
+            if (Py_TYPE(func_prev) == internals->nb_func ||
+                Py_TYPE(func_prev) == internals->nb_method) {
                 func_data *fp = nb_func_data(func_prev);
 
                 check((fp->flags & (uint32_t) func_flags::is_method) ==
                           (f->flags & (uint32_t) func_flags::is_method),
                       "nb::detail::nb_func_new(\"%s\"): mismatched static/"
                       "instance method flags in function overloads!",
                       f->name);
@@ -217,15 +216,19 @@
                       "nb::detail::nb_func_new(\"%s\"): cannot overload "
                       "existing non-function object of the same name!", f->name);
             }
         } else {
             PyErr_Clear();
         }
 
-        is_constructor = strcmp(f->name, "__init__") == 0;
+        // Is this method a constructor that takes a class binding as first parameter?
+        is_constructor = is_method &&
+                         (strcmp(f->name, "__init__") == 0 ||
+                          strcmp(f->name, "__setstate__") == 0) &&
+                         strncmp(f->descr, "({%}", 4) == 0;
 
         // Don't use implicit conversions in copy constructors (causes infinite recursion)
         if (is_constructor && f->nargs == 2 && f->descr_types[0] &&
             f->descr_types[0] == f->descr_types[1]) {
             if (has_args) {
                 f->args[1].convert = false;
             } else {
@@ -234,15 +237,15 @@
             }
         }
     }
 
     // Create a new function and destroy the old one
     Py_ssize_t to_copy = func_prev ? Py_SIZE(func_prev) : 0;
     nb_func *func = (nb_func *) PyType_GenericAlloc(
-        is_method ? internals.nb_method : internals.nb_func, to_copy + 1);
+        is_method ? internals->nb_method : internals->nb_func, to_copy + 1);
     check(func, "nb::detail::nb_func_new(\"%s\"): alloc. failed (1).",
           has_name ? f->name : "<anonymous>");
 
     func->max_nargs_pos = f->nargs;
     func->complex_call = has_args || has_var_args || has_var_kwargs;
 
     if (func_prev) {
@@ -254,27 +257,27 @@
                   *prev = nb_func_data(func_prev);
 
         memcpy(cur, prev, sizeof(func_data) * to_copy);
         memset(prev, 0, sizeof(func_data) * to_copy);
 
         ((PyVarObject *) func_prev)->ob_size = 0;
 
-        auto it = internals.funcs.find(func_prev);
-        check(it != internals.funcs.end(),
+        auto it = internals->funcs.find(func_prev);
+        check(it != internals->funcs.end(),
               "nanobind::detail::nb_func_new(): internal update failed (1)!");
-        internals.funcs.erase(it);
+        internals->funcs.erase(it);
     }
 
     func->complex_call |= func->max_nargs_pos >= NB_MAXARGS_SIMPLE;
 
     func->vectorcall = func->complex_call ? nb_func_vectorcall_complex
                                           : nb_func_vectorcall_simple;
 
     // Register the function
-    auto [it, success] = internals.funcs.try_emplace(func, nullptr);
+    auto [it, success] = internals->funcs.try_emplace(func, nullptr);
     check(success,
           "nanobind::detail::nb_func_new(): internal update failed (2)!");
 
     func_data *fc = nb_func_data(func) + to_copy;
     memcpy(fc, f, sizeof(func_data_prelim<0>));
 
 
@@ -426,26 +429,23 @@
     return nullptr;
 }
 
 /// Used by nb_func_vectorcall: convert a C++ exception into a Python error
 static NB_NOINLINE void nb_func_convert_cpp_exception() noexcept {
     std::exception_ptr e = std::current_exception();
 
-    nb_translator_seq *cur  = &internals_get().translators;
-
-    while (cur) {
+    for (nb_translator_seq *cur = &internals->translators; cur;
+         cur = cur->next) {
         try {
             // Try exception translator & forward payload
             cur->translator(e, cur->payload);
             return;
         } catch (...) {
             e = std::current_exception();
         }
-
-        cur = cur->next;
     }
 
     PyErr_SetString(PyExc_SystemError,
                     "nanobind::detail::nb_func_error_except(): exception "
                     "could not be translated!");
 }
 
@@ -456,58 +456,31 @@
                                             PyObject *kwargs_in) noexcept {
     const size_t count      = (size_t) Py_SIZE(self),
                  nargs_in   = (size_t) NB_VECTORCALL_NARGS(nargsf),
                  nkwargs_in = kwargs_in ? (size_t) NB_TUPLE_GET_SIZE(kwargs_in) : 0;
 
     func_data *fr = nb_func_data(self);
 
-    const bool is_method = fr->flags & (uint32_t) func_flags::is_method;
-    bool is_constructor = false;
-
-    uint32_t self_flags = 0;
-
-    PyObject *result = nullptr, *self_arg = nullptr;
+    const bool is_method      = fr->flags & (uint32_t) func_flags::is_method,
+               is_constructor = fr->flags & (uint32_t) func_flags::is_constructor;
 
-    if (is_method) {
-        self_arg = nargs_in > 0 ? args_in[0] : nullptr;
-
-        if (NB_LIKELY(self_arg)) {
-            PyTypeObject *self_tp = Py_TYPE(self_arg);
-
-            if (NB_LIKELY(nb_type_check((PyObject *) self_tp))) {
-                self_flags = nb_type_data(self_tp)->flags;
-                if (self_flags & (uint32_t) type_flags::is_trampoline)
-                    current_method_data = current_method{ fr->name, self_arg };
-
-                is_constructor = fr->flags & (uint32_t) func_flags::is_constructor;
-                if (is_constructor) {
-                    if (((nb_inst *) self_arg)->ready) {
-                        PyErr_SetString(
-                            PyExc_RuntimeError,
-                            "nanobind::detail::nb_func_vectorcall(): the __init__ "
-                            "method should not be called on an initialized object!");
-                        return nullptr;
-                    }
-                }
-            }
-        }
-    }
+    PyObject *result = nullptr,
+             *self_arg = (is_method && nargs_in > 0) ? args_in[0] : nullptr;
 
     /* The following lines allocate memory on the stack, which is very efficient
        but also potentially dangerous since it can be used to generate stack
        overflows. We refuse unrealistically large number of 'kwargs' (the
        'max_nargs_pos' value is fine since it is specified by the bindings) */
     if (nkwargs_in > 1024) {
         PyErr_SetString(PyExc_TypeError,
                         "nanobind::detail::nb_func_vectorcall(): too many (> "
                         "1024) keyword arguments.");
         return nullptr;
     }
 
-
     // Handler routine that will be invoked in case of an error condition
     PyObject *(*error_handler)(PyObject *, PyObject *const *, size_t,
                                PyObject *) noexcept = nullptr;
 
     // Small array holding temporaries (implicit conversion/*args/**kwargs)
     cleanup_list cleanup(self_arg);
 
@@ -684,82 +657,53 @@
             }
 
             if (result != NB_NEXT_OVERLOAD) {
                 if (is_constructor) {
                     nb_inst *self_arg_nb = (nb_inst *) self_arg;
                     self_arg_nb->destruct = true;
                     self_arg_nb->ready = true;
-
-                    if (NB_UNLIKELY(self_flags & (uint32_t) type_flags::intrusive_ptr))
+                    if (NB_UNLIKELY(self_arg_nb->intrusive))
                         nb_type_data(Py_TYPE(self_arg))
                             ->set_self_py(inst_ptr(self_arg_nb), self_arg);
                 }
 
                 goto done;
             }
         }
     }
 
     error_handler = nb_func_error_overload;
 
 done:
     cleanup.release();
 
-    if (error_handler)
+    if (NB_UNLIKELY(error_handler))
         result = error_handler(self, args_in, nargs_in, kwargs_in);
 
-    if (self_flags & (uint32_t) type_flags::is_trampoline)
-        current_method_data = current_method{ nullptr, nullptr };
-
     return result;
 }
 
 /// Simplified nb_func_vectorcall variant for functions w/o keyword arguments
 static PyObject *nb_func_vectorcall_simple(PyObject *self,
                                            PyObject *const *args_in,
                                            size_t nargsf,
                                            PyObject *kwargs_in) noexcept {
     uint8_t args_flags[NB_MAXARGS_SIMPLE];
     func_data *fr = nb_func_data(self);
 
     const size_t count         = (size_t) Py_SIZE(self),
                  nargs_in      = (size_t) NB_VECTORCALL_NARGS(nargsf);
 
-    const bool is_method = fr->flags & (uint32_t) func_flags::is_method;
-    bool is_constructor = false;
-
-    uint32_t self_flags = 0;
-
-    PyObject *result = nullptr, *self_arg = nullptr;
+    const bool is_method      = fr->flags & (uint32_t) func_flags::is_method,
+               is_constructor = fr->flags & (uint32_t) func_flags::is_constructor;
 
-    if (is_method) {
-        self_arg = nargs_in > 0 ? args_in[0] : nullptr;
+    PyObject *result = nullptr,
+             *self_arg = (is_method && nargs_in > 0) ? args_in[0] : nullptr;
 
-        if (NB_LIKELY(self_arg)) {
-            PyTypeObject *self_tp = Py_TYPE(self_arg);
-            if (NB_LIKELY(nb_type_check((PyObject *) self_tp))) {
-                self_flags = nb_type_data(self_tp)->flags;
-                if (NB_UNLIKELY(self_flags & (uint32_t) type_flags::is_trampoline))
-                    current_method_data = current_method{ fr->name, self_arg };
-
-                is_constructor = fr->flags & (uint32_t) func_flags::is_constructor;
-                if (is_constructor) {
-                    if (NB_UNLIKELY(((nb_inst *) self_arg)->ready)) {
-                        PyErr_SetString(PyExc_RuntimeError,
-                                        "nanobind::detail::nb_func_vectorcall_simple():"
-                                        " the __init__ method should not be called on "
-                                        "an initialized object!");
-                        return nullptr;
-                    }
-                }
-            }
-        }
-    }
-
-    /// Small array holding temporaries (implicit conversion/*args/**kwargs)
+    // Small array holding temporaries (implicit conversion/*args/**kwargs)
     cleanup_list cleanup(self_arg);
 
     // Handler routine that will be invoked in case of an error condition
     PyObject *(*error_handler)(PyObject *, PyObject *const *, size_t,
                                PyObject *) noexcept = nullptr;
 
     bool fail = kwargs_in != nullptr;
@@ -813,16 +757,15 @@
             }
 
             if (result != NB_NEXT_OVERLOAD) {
                 if (is_constructor) {
                     nb_inst *self_arg_nb = (nb_inst *) self_arg;
                     self_arg_nb->destruct = true;
                     self_arg_nb->ready = true;
-
-                    if (NB_UNLIKELY(self_flags & (uint32_t) type_flags::intrusive_ptr))
+                    if (NB_UNLIKELY(self_arg_nb->intrusive))
                         nb_type_data(Py_TYPE(self_arg))
                             ->set_self_py(inst_ptr(self_arg_nb), self_arg);
                 }
 
                 goto done;
             }
         }
@@ -832,17 +775,14 @@
 
 done:
     cleanup.release();
 
     if (NB_UNLIKELY(error_handler))
         result = error_handler(self, args_in, nargs_in, kwargs_in);
 
-    if (NB_UNLIKELY(self_flags & (uint32_t) type_flags::is_trampoline))
-        current_method_data = current_method{ nullptr, nullptr };
-
     return result;
 }
 
 static PyObject *nb_bound_method_vectorcall(PyObject *self,
                                             PyObject *const *args_in,
                                             size_t nargsf,
                                             PyObject *kwargs_in) noexcept {
@@ -874,15 +814,15 @@
 PyObject *nb_method_descr_get(PyObject *self, PyObject *inst, PyObject *) {
     if (inst) {
         /* Return a bound method. This should be avoidable in most cases via the
            'CALL_METHOD' opcode and vector calls. Pytest rewrites the bytecode
            in a way that breaks this optimization :-/ */
 
         nb_bound_method *mb =
-            PyObject_GC_New(nb_bound_method, internals_get().nb_bound_method);
+            PyObject_GC_New(nb_bound_method, internals->nb_bound_method);
         mb->func = (nb_func *) self;
         mb->self = inst;
         mb->vectorcall = nb_bound_method_vectorcall;
 
         Py_INCREF(self);
         Py_INCREF(inst);
 
@@ -898,15 +838,14 @@
 static void nb_func_render_signature(const func_data *f) noexcept {
     const bool is_method      = f->flags & (uint32_t) func_flags::is_method,
                has_args       = f->flags & (uint32_t) func_flags::has_args,
                has_var_args   = f->flags & (uint32_t) func_flags::has_var_args,
                has_var_kwargs = f->flags & (uint32_t) func_flags::has_var_kwargs;
 
     const std::type_info **descr_type = f->descr_types;
-    nb_internals &internals = internals_get();
 
     uint32_t arg_index = 0;
     buf.put_dstr(f->name);
 
     for (const char *pc = f->descr; *pc != '\0'; ++pc) {
         char c = *pc;
 
@@ -992,20 +931,20 @@
                 if (arg_index == f->nargs - has_var_args - has_var_kwargs && !has_args)
                     buf.put(", /");
 
                 break;
 
             case '%':
                 check(*descr_type,
-                      "nb::detail::nb_func_finalize(): missing type!");
+                      "nb::detail::nb_func_render_signature(): missing type!");
 
                 if (!(is_method && arg_index == 0)) {
-                    auto it = internals.type_c2p.find(std::type_index(**descr_type));
+                    auto it = internals->type_c2p.find(std::type_index(**descr_type));
 
-                    if (it != internals.type_c2p.end()) {
+                    if (it != internals->type_c2p.end()) {
                         handle th((PyObject *) it->second->type_py);
                         buf.put_dstr((borrow<str>(th.attr("__module__"))).c_str());
                         buf.put('.');
                         buf.put_dstr((borrow<str>(th.attr("__qualname__"))).c_str());
                     } else {
                         char *name = type_name(*descr_type);
                         buf.put_dstr(name);
@@ -1019,15 +958,15 @@
             default:
                 buf.put(c);
                 break;
         }
     }
 
     check(arg_index == f->nargs && !*descr_type,
-          "nanobind::detail::nb_func_finalize(%s): arguments inconsistent.",
+          "nanobind::detail::nb_func_render_signature(%s): arguments inconsistent.",
           f->name);
 }
 
 static PyObject *nb_func_get_name(PyObject *self) {
     func_data *f = nb_func_data(self);
     if (f->flags & (uint32_t) func_flags::has_name) {
         return PyUnicode_FromString(f->name);
```

## nanobind/src/nb_internals.cpp

```diff
@@ -13,15 +13,15 @@
 
 #if defined(__GNUC__) && !defined(__clang__)
 #  pragma GCC diagnostic ignored "-Wmissing-field-initializers"
 #endif
 
 /// Tracks the ABI of nanobind
 #ifndef NB_INTERNALS_VERSION
-#  define NB_INTERNALS_VERSION 8
+#  define NB_INTERNALS_VERSION 9
 #endif
 
 /// On MSVC, debug and release builds are not ABI-compatible!
 #if defined(_MSC_VER) && defined(_DEBUG)
 #  define NB_BUILD_TYPE "_debug"
 #else
 #  define NB_BUILD_TYPE ""
@@ -58,22 +58,24 @@
 /// On Linux/OSX, changes in __GXX_ABI_VERSION__ indicate ABI incompatibility.
 #if defined(__GXX_ABI_VERSION)
 #  define NB_BUILD_ABI "_cxxabi" NB_TOSTRING(__GXX_ABI_VERSION)
 #else
 #  define NB_BUILD_ABI ""
 #endif
 
+// Can have limited and non-limited-API extensions in the same process, and they might be incompatible
 #if defined(Py_LIMITED_API)
-#  define NB_LIMITED_API "_limited"
+#  define NB_STABLE_ABI "_stable"
 #else
-#  define NB_LIMITED_API ""
+#  define NB_STABLE_ABI ""
 #endif
 
-#define NB_INTERNALS_ID "__nb_internals_v" \
-    NB_TOSTRING(NB_INTERNALS_VERSION) NB_COMPILER_TYPE NB_STDLIB NB_BUILD_ABI NB_BUILD_TYPE NB_LIMITED_API "__"
+#define NB_INTERNALS_ID                                                        \
+    "v" NB_TOSTRING(NB_INTERNALS_VERSION)                                      \
+        NB_COMPILER_TYPE NB_STDLIB NB_BUILD_ABI NB_BUILD_TYPE NB_STABLE_ABI
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 extern PyObject *nb_func_getattro(PyObject *, PyObject *);
 extern PyObject *nb_func_get_doc(PyObject *, void *);
 extern PyObject *nb_bound_method_getattro(PyObject *, PyObject *);
@@ -186,19 +188,14 @@
     /* .basicsize = */ (int) sizeof(nb_bound_method),
     /* .itemsize = */ 0,
     /* .flags = */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
                    NB_HAVE_VECTORCALL_PY39_OR_NEWER,
     /* .slots = */ nb_bound_method_slots
 };
 
-NB_THREAD_LOCAL current_method current_method_data =
-    current_method{ nullptr, nullptr };
-
-nb_internals *internals_p = nullptr;
-
 void default_exception_translator(const std::exception_ptr &p, void *) {
     try {
         std::rethrow_exception(p);
     } catch (const std::bad_alloc &e) {
         PyErr_SetString(PyExc_MemoryError, e.what());
     } catch (const std::domain_error &e) {
         PyErr_SetString(PyExc_ValueError, e.what());
@@ -213,122 +210,133 @@
     } catch (const std::overflow_error &e) {
         PyErr_SetString(PyExc_OverflowError, e.what());
     } catch (const std::exception &e) {
         PyErr_SetString(PyExc_RuntimeError, e.what());
     }
 }
 
+nb_internals *internals = nullptr;
+PyTypeObject *nb_meta_cache = nullptr;
+
 #if !defined(PYPY_VERSION)
 static void internals_cleanup() {
+    if (!internals)
+        return;
+
     bool leak = false;
 
-    if (!internals_p->inst_c2p.empty()) {
-        if (internals_p->print_leak_warnings) {
+    if (!internals->inst_c2p.empty()) {
+        if (internals->print_leak_warnings) {
             fprintf(stderr, "nanobind: leaked %zu instances!\n",
-                    internals_p->inst_c2p.size());
+                    internals->inst_c2p.size());
         }
         leak = true;
     }
 
-    if (!internals_p->keep_alive.empty()) {
-        if (internals_p->print_leak_warnings) {
+    if (!internals->keep_alive.empty()) {
+        if (internals->print_leak_warnings) {
             fprintf(stderr, "nanobind: leaked %zu keep_alive records!\n",
-                    internals_p->keep_alive.size());
+                    internals->keep_alive.size());
         }
         leak = true;
     }
 
-    if (!internals_p->type_c2p.empty()) {
-        if (internals_p->print_leak_warnings) {
+    if (!internals->type_c2p.empty()) {
+        if (internals->print_leak_warnings) {
             fprintf(stderr, "nanobind: leaked %zu types!\n",
-                    internals_p->type_c2p.size());
+                    internals->type_c2p.size());
             int ctr = 0;
-            for (const auto &kv : internals_p->type_c2p) {
+            for (const auto &kv : internals->type_c2p) {
                 fprintf(stderr, " - leaked type \"%s\"\n", kv.second->name);
                 if (ctr++ == 10) {
                     fprintf(stderr, " - ... skipped remainder\n");
                     break;
                 }
             }
         }
         leak = true;
     }
 
-    if (!internals_p->funcs.empty()) {
-        if (internals_p->print_leak_warnings) {
+    if (!internals->funcs.empty()) {
+        if (internals->print_leak_warnings) {
             fprintf(stderr, "nanobind: leaked %zu functions!\n",
-                    internals_p->funcs.size());
+                    internals->funcs.size());
             int ctr = 0;
-            for (auto [f, p] : internals_p->funcs) {
+            for (auto [f, p] : internals->funcs) {
                 fprintf(stderr, " - leaked function \"%s\"\n",
                         nb_func_data(f)->name);
                 if (ctr++ == 10) {
                     fprintf(stderr, " - ... skipped remainder\n");
                     break;
                 }
             }
         }
         leak = true;
     }
 
     if (!leak) {
-        delete internals_p;
-        internals_p = nullptr;
+        delete internals;
+        internals = nullptr;
+        nb_meta_cache = nullptr;
     } else {
-        if (internals_p->print_leak_warnings) {
+        if (internals->print_leak_warnings) {
             fprintf(stderr, "nanobind: this is likely caused by a reference "
                             "counting issue in the binding code.\n");
         }
 
 #if NB_ABORT_ON_LEAK == 1
         abort(); // Extra-strict behavior for the CI server
 #endif
     }
 }
 #endif
 
-static PyObject *internals_dict() {
+NB_NOINLINE void init(const char *name) {
+    if (internals)
+        return;
+
 #if defined(PYPY_VERSION)
     PyObject *dict = PyEval_GetBuiltins();
 #elif PY_VERSION_HEX < 0x03090000
     PyObject *dict = PyInterpreterState_GetDict(_PyInterpreterState_Get());
 #else
     PyObject *dict = PyInterpreterState_GetDict(PyInterpreterState_Get());
 #endif
-    check(dict, "nanobind::detail::internals_dict(): failed!");
+    check(dict, "nanobind::detail::init(): could not access internals dictionary!");
 
-    return dict;
-}
+    PyObject *key = PyUnicode_FromFormat("__nb_internals_%s_%s__",
+                                         NB_INTERNALS_ID, name ? name : "");
+    check(key, "nanobind::detail::init(): could not create dictionary key!");
 
-static NB_NOINLINE nb_internals *internals_make() {
-    str nb_name("nanobind");
+    PyObject *capsule = PyDict_GetItem(dict, key);
+    if (capsule) {
+        Py_DECREF(key);
+        internals = (nb_internals *) PyCapsule_GetPointer(capsule, "nb_internals");
+        check(internals,
+              "nanobind::detail::internals_fetch(): capsule pointer is NULL!");
+        nb_meta_cache = internals->nb_meta;
+        return;
+    }
 
     nb_internals *p = new nb_internals();
 
-    PyObject *dict = internals_dict();
 
-    const char *internals_id = NB_INTERNALS_ID;
-    PyObject *capsule = PyCapsule_New(p, internals_id, nullptr);
-    int rv = PyDict_SetItemString(dict, internals_id, capsule);
-    check(!rv && capsule,
-          "nanobind::detail::internals_make(): allocation failed!");
-    Py_DECREF(capsule);
+    str nb_name("nanobind");
+    p->nb_module = PyModule_NewObject(nb_name.ptr());
 
     nb_meta_slots[0].pfunc = (PyObject *) &PyType_Type;
-
-    p->nb_module = PyModule_NewObject(nb_name.ptr());
-    p->nb_meta = (PyTypeObject *) PyType_FromSpec(&nb_meta_spec);
+    nb_meta_cache = p->nb_meta = (PyTypeObject *) PyType_FromSpec(&nb_meta_spec);
     p->nb_type_dict = PyDict_New();
     p->nb_func = (PyTypeObject *) PyType_FromSpec(&nb_func_spec);
     p->nb_method = (PyTypeObject *) PyType_FromSpec(&nb_method_spec);
     p->nb_bound_method = (PyTypeObject *) PyType_FromSpec(&nb_bound_method_spec);
 
     check(p->nb_module && p->nb_meta && p->nb_type_dict && p->nb_func &&
               p->nb_method && p->nb_bound_method,
-          "nanobind::detail::internals_make(): initialization failed!");
+          "nanobind::detail::init(): initialization failed!");
 
 #if PY_VERSION_HEX < 0x03090000
     p->nb_func->tp_flags |= NB_HAVE_VECTORCALL;
     p->nb_func->tp_vectorcall_offset = offsetof(nb_func, vectorcall);
     p->nb_method->tp_flags |= NB_HAVE_VECTORCALL;
     p->nb_method->tp_vectorcall_offset = offsetof(nb_func, vectorcall);
     p->nb_bound_method->tp_flags |= NB_HAVE_VECTORCALL;
@@ -392,35 +400,22 @@
         fprintf(stderr,
                 "Warning: could not install the nanobind cleanup handler! This "
                 "is needed to check for reference leaks and release remaining "
                 "resources at interpreter shutdown (e.g., to avoid leaks being "
                 "reported by tools like 'valgrind'). If you are a user of a "
                 "python extension library, you can ignore this warning.");
 #endif
-    return p;
-}
-
-nb_internals *internals_fetch() {
-    PyObject *dict = internals_dict();
 
-    const char *internals_id = NB_INTERNALS_ID;
-    PyObject *capsule = PyDict_GetItemString(dict, internals_id);
-
-    nb_internals *ptr;
-    if (capsule) {
-        ptr = (nb_internals *) PyCapsule_GetPointer(capsule, internals_id);
-        check(ptr,
-              "nanobind::detail::internals_fetch(): capsule pointer is NULL!");
-    } else {
-        ptr = internals_make();
-    }
-
-    internals_p = ptr;
-
-    return ptr;
+    capsule = PyCapsule_New(p, "nb_internals", nullptr);
+    int rv = PyDict_SetItem(dict, key, capsule);
+    check(!rv && capsule,
+          "nanobind::detail::init(): capsule creation failed!");
+    Py_DECREF(capsule);
+    Py_DECREF(key);
+    internals = p;
 }
 
 #if defined(NB_COMPACT_ASSERTIONS)
 NB_NOINLINE void fail_unspecified() noexcept {
     fail("nanobind: encountered an unrecoverable error condition. Recompile "
          "using the 'Debug' or 'RelWithDebInfo' modes to obtain further "
          "information about this problem.");
```

## nanobind/src/nb_internals.h

```diff
@@ -62,14 +62,17 @@
     bool destruct : 1;
 
     /// Should nanobind call 'operator delete' when this instance is GCed?
     bool cpp_delete : 1;
 
     /// Does this instance hold reference to others? (via internals.keep_alive)
     bool clear_keep_alive : 1;
+
+    /// Does this instance use intrusive reference counting?
+    bool intrusive : 1;
 };
 
 static_assert(sizeof(nb_inst) == sizeof(PyObject) + sizeof(uint32_t) * 2);
 
 /// Python object representing a bound C++ function
 struct nb_func {
     PyObject_VAR_HEAD
@@ -237,34 +240,21 @@
     descrgetfunc PyProperty_Type_tp_descr_get;
     descrsetfunc PyProperty_Type_tp_descr_set;
 #endif
 };
 
 /// Convenience macro to potentially access cached functions
 #if defined(Py_LIMITED_API)
-#  define NB_SLOT(internals, type, name) internals.type##_##name
+#  define NB_SLOT(type, name) internals->type##_##name
 #else
-#  define NB_SLOT(internals, type, name) type.name
+#  define NB_SLOT(type, name) type.name
 #endif
 
-struct current_method {
-    const char *name;
-    PyObject *self;
-};
-
-extern NB_THREAD_LOCAL current_method current_method_data;
-extern nb_internals *internals_p;
-extern nb_internals *internals_fetch();
-
-inline nb_internals &internals_get() noexcept {
-    nb_internals *ptr = internals_p;
-    if (NB_UNLIKELY(!ptr))
-        ptr = internals_fetch();
-    return *ptr;
-}
+extern nb_internals *internals;
+extern PyTypeObject *nb_meta_cache;
 
 extern char *type_name(const std::type_info *t);
 
 // Forward declarations
 extern PyObject *inst_new_impl(PyTypeObject *tp, void *value);
 extern PyTypeObject *nb_static_property_tp() noexcept;
```

## nanobind/src/nb_ndarray.cpp

```diff
@@ -119,16 +119,15 @@
 
 static void nb_ndarray_releasebuffer(PyObject *, Py_buffer *view) {
     PyMem_Free(view->shape);
     PyMem_Free(view->strides);
 }
 
 static PyTypeObject *nd_ndarray_tp() noexcept {
-    nb_internals &internals = internals_get();
-    PyTypeObject *tp = internals.nb_ndarray;
+    PyTypeObject *tp = internals->nb_ndarray;
 
     if (NB_UNLIKELY(!tp)) {
         PyType_Slot slots[] = {
             { Py_tp_dealloc, (void *) nb_ndarray_dealloc },
 #if PY_VERSION_HEX >= 0x03090000
             { Py_bf_getbuffer, (void *) nd_ndarray_tpbuffer },
             { Py_bf_releasebuffer, (void *) nb_ndarray_releasebuffer },
@@ -148,15 +147,15 @@
         check(tp, "nb_ndarray type creation failed!");
 
 #if PY_VERSION_HEX < 0x03090000
         tp->tp_as_buffer->bf_getbuffer = nd_ndarray_tpbuffer;
         tp->tp_as_buffer->bf_releasebuffer = nb_ndarray_releasebuffer;
 #endif
 
-        internals.nb_ndarray = tp;
+        internals->nb_ndarray = tp;
     }
 
     return tp;
 }
 
 static PyObject *dlpack_from_buffer_protocol(PyObject *o, bool ro) {
     scoped_pymalloc<Py_buffer> view;
```

## nanobind/src/nb_static_property.cpp

```diff
@@ -1,32 +1,30 @@
 #include "nb_internals.h"
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 /// `nb_static_property.__get__()`: Always pass the class instead of the instance.
 static PyObject *nb_static_property_descr_get(PyObject *self, PyObject *, PyObject *cls) {
-    nb_internals &internals = internals_get();
-    if (internals.nb_static_property_enabled) {
-        return NB_SLOT(internals, PyProperty_Type, tp_descr_get)(self, cls, cls);
+    if (internals->nb_static_property_enabled) {
+        return NB_SLOT(PyProperty_Type, tp_descr_get)(self, cls, cls);
     } else {
         Py_INCREF(self);
         return self;
     }
 }
 
 /// `nb_static_property.__set__()`: Just like the above `__get__()`.
 static int nb_static_property_descr_set(PyObject *self, PyObject *obj, PyObject *value) {
     PyObject *cls = PyType_Check(obj) ? obj : (PyObject *) Py_TYPE(obj);
-    return NB_SLOT(internals_get(), PyProperty_Type, tp_descr_set)(self, cls, value);
+    return NB_SLOT(PyProperty_Type, tp_descr_set)(self, cls, value);
 }
 
 PyTypeObject *nb_static_property_tp() noexcept {
-    nb_internals &internals = internals_get();
-    PyTypeObject *tp = internals.nb_static_property;
+    PyTypeObject *tp = internals->nb_static_property;
 
     if (NB_UNLIKELY(!tp)) {
         PyType_Slot members;
 
         #if PY_VERSION_HEX >= 0x030C0000
             int basicsize = - (int) sizeof(PyObject *),
                 itemsize = 0;
@@ -59,16 +57,16 @@
             /* .flags = */ Py_TPFLAGS_DEFAULT,
             /* .slots = */ slots
         };
 
         tp = (PyTypeObject *) PyType_FromSpec(&spec);
         check(tp, "nb_static_property type creation failed!");
 
-        internals.nb_static_property = tp;
-        internals.nb_static_property_descr_set = nb_static_property_descr_set;
+        internals->nb_static_property = tp;
+        internals->nb_static_property_descr_set = nb_static_property_descr_set;
     }
 
     return tp;
 }
 
 NAMESPACE_END(NB_NAMESPACE)
 NAMESPACE_END(detail)
```

## nanobind/src/nb_type.cpp

```diff
@@ -110,17 +110,18 @@
             self->offset = (int32_t) sizeof(nb_inst);
             self->direct = false;
         }
 
         self->internal = false;
     }
 
+    self->intrusive = t->flags & (uint32_t) type_flags::intrusive_ptr;
+
     // Update hash table that maps from C++ to Python instance
-    auto [it, success] =
-        internals_get().inst_c2p.try_emplace(value, self);
+    auto [it, success] = internals->inst_c2p.try_emplace(value, self);
 
     if (NB_UNLIKELY(!success)) {
         void *entry = it->second;
 
         // Potentially convert the map value into linked list format
         if (!nb_is_seq(entry)) {
             nb_inst_seq *first = (nb_inst_seq *) PyMem_Malloc(sizeof(nb_inst_seq));
@@ -184,38 +185,38 @@
     if (inst->cpp_delete) {
         if (t->align <= (uint32_t) __STDCPP_DEFAULT_NEW_ALIGNMENT__)
             operator delete(p);
         else
             operator delete(p, std::align_val_t(t->align));
     }
 
-    nb_internals &internals = internals_get();
     if (inst->clear_keep_alive) {
-        auto it = internals.keep_alive.find(self);
-        check(it != internals.keep_alive.end(),
+        nb_ptr_map &keep_alive = internals->keep_alive;
+        nb_ptr_map::iterator it = keep_alive.find(self);
+        check(it != keep_alive.end(),
               "nanobind::detail::inst_dealloc(\"%s\"): inconsistent "
               "keep_alive information", t->name);
 
         nb_weakref_seq *s = (nb_weakref_seq *) it->second;
-        internals.keep_alive.erase(it);
+        keep_alive.erase(it);
         do {
             nb_weakref_seq *c = s;
             s = c->next;
 
             if (c->callback)
                 c->callback(c->payload);
             else
                 Py_DECREF((PyObject *) c->payload);
 
             PyObject_Free(c);
         } while (s);
     }
 
     // Update hash table that maps from C++ to Python instance
-    nb_ptr_map &inst_c2p = internals.inst_c2p;
+    nb_ptr_map &inst_c2p = internals->inst_c2p;
     nb_ptr_map::iterator it = inst_c2p.find(p);
     bool found = false;
 
     if (NB_LIKELY(it != inst_c2p.end())) {
         void *entry = it->second;
         if (NB_LIKELY(entry == inst)) {
             found = true;
@@ -249,41 +250,41 @@
     }
 
     check(found,
           "nanobind::detail::inst_dealloc(\"%s\"): attempted to delete an "
           "unknown instance (%p)!", t->name, p);
 
     if (NB_UNLIKELY(gc))
-        NB_SLOT(internals, PyType_Type, tp_free)(self);
+        NB_SLOT(PyType_Type, tp_free)(self);
     else
         PyObject_Free(self);
 
     Py_DECREF(tp);
 }
 
 static void nb_type_dealloc(PyObject *o) {
     type_data *t = nb_type_data((PyTypeObject *) o);
 
     if (t->type && (t->flags & (uint32_t) type_flags::is_python_type) == 0) {
-        nb_type_map &type_c2p = internals_get().type_c2p;
+        nb_type_map &type_c2p = internals->type_c2p;
         nb_type_map::iterator it = type_c2p.find(std::type_index(*t->type));
         check(it != type_c2p.end(),
               "nanobind::detail::nb_type_dealloc(\"%s\"): could not "
               "find type!", t->name);
         type_c2p.erase(it);
     }
 
     if (t->flags & (uint32_t) type_flags::has_implicit_conversions) {
         free(t->implicit);
         free(t->implicit_py);
     }
 
     free((char *) t->name);
 
-    NB_SLOT(internals_get(), PyType_Type, tp_dealloc)(o);
+    NB_SLOT(PyType_Type, tp_dealloc)(o);
 }
 
 /// Called when a C++ type is extended from within Python
 static int nb_type_init(PyObject *self, PyObject *args, PyObject *kwds) {
     if (NB_TUPLE_GET_SIZE(args) != 3) {
         PyErr_SetString(PyExc_RuntimeError,
                         "nb_type_init(): invalid number of arguments!");
@@ -306,15 +307,15 @@
     type_data *t_b = nb_type_data((PyTypeObject *) base);
     if (t_b->flags & (uint32_t) type_flags::is_final) {
         PyErr_Format(PyExc_TypeError, "The type '%s' prohibits subclassing!",
                      t_b->name);
         return -1;
     }
 
-    int rv = NB_SLOT(internals_get(), PyType_Type, tp_init)(self, args, kwds);
+    int rv = NB_SLOT(PyType_Type, tp_init)(self, args, kwds);
     if (rv)
         return rv;
 
     type_data *t = nb_type_data((PyTypeObject *) self);
 
     *t = *t_b;
     t->flags |=  (uint32_t) type_flags::is_python_type;
@@ -327,24 +328,23 @@
     t->implicit_py = nullptr;
 
     return 0;
 }
 
 /// Special case to handle 'Class.property = value' assignments
 static int nb_type_setattro(PyObject* obj, PyObject* name, PyObject* value) {
-    nb_internals &internals = internals_get();
-
-    internals.nb_static_property_enabled = false;
+    nb_internals *int_p = internals;
+    int_p->nb_static_property_enabled = false;
     PyObject *cur = PyObject_GetAttr(obj, name);
-    internals.nb_static_property_enabled = true;
+    int_p->nb_static_property_enabled = true;
 
     if (cur) {
-        PyTypeObject *tp = internals.nb_static_property;
+        PyTypeObject *tp = int_p->nb_static_property;
         if (Py_TYPE(cur) == tp) {
-            int rv = internals.nb_static_property_descr_set(cur, obj, value);
+            int rv = int_p->nb_static_property_descr_set(cur, obj, value);
             Py_DECREF(cur);
             return rv;
         }
         Py_DECREF(cur);
 
         const char *cname = PyUnicode_AsUTF8AndSize(name, nullptr);
         if (!cname) {
@@ -360,15 +360,15 @@
                          "reassigned or deleted.", cname);
             return -1;
         }
     } else {
         PyErr_Clear();
     }
 
-    return NB_SLOT(internals, PyType_Type, tp_setattro)(obj, name, value);
+    return NB_SLOT(PyType_Type, tp_setattro)(obj, name, value);
 }
 
 #if PY_VERSION_HEX < 0x030C0000
 #  if PY_VERSION_HEX < 0x03090000
 #    define Py_bf_getbuffer 1
 #    define Py_bf_releasebuffer 2
 #  endif
@@ -596,20 +596,19 @@
         return nullptr;
     }
 
     return (PyObject *) tp;
 #endif
 }
 
-static PyTypeObject *nb_type_tp(nb_internals &internals,
-                                size_t supplement) noexcept {
+static PyTypeObject *nb_type_tp(size_t supplement) noexcept {
     object key = steal(PyLong_FromSize_t(supplement));
 
     PyTypeObject *tp =
-        (PyTypeObject *) PyDict_GetItem(internals.nb_type_dict, key.ptr());
+        (PyTypeObject *) PyDict_GetItem(internals->nb_type_dict, key.ptr());
 
     if (NB_UNLIKELY(!tp)) {
         PyType_Slot slots[] = {
             { Py_tp_base, &PyType_Type },
             { Py_tp_dealloc, (void *) nb_type_dealloc },
             { Py_tp_setattro, (void *) nb_type_setattro },
             { Py_tp_init, (void *) nb_type_init },
@@ -632,21 +631,21 @@
             /* .basicsize = */ basicsize,
             /* .itemsize = */ itemsize,
             /* .flags = */ Py_TPFLAGS_DEFAULT,
             /* .slots = */ slots
         };
 
         tp = (PyTypeObject *) nb_type_from_metaclass(
-            internals.nb_meta, internals.nb_module, &spec);
+            internals->nb_meta, internals->nb_module, &spec);
 
         handle(tp).attr("__module__") = "nanobind";
 
         int rv = 1;
         if (tp)
-            rv = PyDict_SetItem(internals.nb_type_dict, key.ptr(), (PyObject *) tp);
+            rv = PyDict_SetItem(internals->nb_type_dict, key.ptr(), (PyObject *) tp);
         check(rv == 0, "nb_type type creation failed!");
 
         Py_DECREF(tp);
     }
 
     return tp;
 }
@@ -658,19 +657,28 @@
          has_base_py       = t->flags & (uint32_t) type_init_flags::has_base_py,
          has_type_slots    = t->flags & (uint32_t) type_init_flags::has_type_slots,
          has_supplement    = t->flags & (uint32_t) type_init_flags::has_supplement,
          has_dynamic_attr  = t->flags & (uint32_t) type_flags::has_dynamic_attr,
          intrusive_ptr     = t->flags & (uint32_t) type_flags::intrusive_ptr,
          has_shared_from_this = t->flags & (uint32_t) type_flags::has_shared_from_this;
 
-    nb_internals &internals = internals_get();
     str name(t->name), qualname = name;
     object modname;
     PyObject *mod = nullptr;
 
+    // Update hash table that maps from std::type_info to Python type
+    auto [it, success] =
+        internals->type_c2p.try_emplace(std::type_index(*t->type), nullptr);
+    if (!success) {
+        PyErr_WarnFormat(PyExc_RuntimeWarning, 1, "nanobind: type '%s' was already registered!\n", t->name);
+        PyObject *tp = (PyObject *) it->second->type_py;
+        Py_INCREF(tp);
+        return tp;
+    }
+
     if (t->scope != nullptr) {
         if (PyModule_Check(t->scope)) {
             mod = t->scope;
             modname = getattr(t->scope, "__name__", handle());
         } else {
             modname = getattr(t->scope, "__module__", handle());
 
@@ -697,16 +705,16 @@
               "specified!", t->name);
         base = (PyObject *) t->base_py;
         check(nb_type_check(base),
               "nanobind::detail::nb_type_new(\"%s\"): base type is not a "
               "nanobind type!", t->name);
     } else if (has_base) {
         nb_type_map::iterator it =
-            internals.type_c2p.find(std::type_index(*t->base));
-        check(it != internals.type_c2p.end(),
+            internals->type_c2p.find(std::type_index(*t->base));
+        check(it != internals->type_c2p.end(),
                   "nanobind::detail::nb_type_new(\"%s\"): base type \"%s\" not "
                   "known to nanobind!", t->name, type_name(t->base));
         base = (PyObject *) it->second->type_py;
     }
 
     type_data *tb = nullptr;
     if (base) {
@@ -799,16 +807,15 @@
 
     if (has_traverse && (!base || (PyType_GetFlags((PyTypeObject *) base) &
                                    Py_TPFLAGS_HAVE_GC) == 0))
         spec.flags |= Py_TPFLAGS_HAVE_GC;
 
     *s++ = { 0, nullptr };
 
-    PyTypeObject *metaclass =
-        nb_type_tp(internals, has_supplement ? t->supplement : 0);
+    PyTypeObject *metaclass = nb_type_tp(has_supplement ? t->supplement : 0);
 
     PyObject *result = nb_type_from_metaclass(metaclass, mod, &spec);
     if (!result) {
         python_error err;
         check(false,
               "nanobind::detail::nb_type_new(\"%s\"): type construction "
               "failed: %s!", t->name, err.what());
@@ -844,43 +851,38 @@
         setattr(t->scope, t->name, result);
 
     setattr(result, "__qualname__", qualname.ptr());
 
     if (modname.is_valid())
         setattr(result, "__module__", modname.ptr());
 
-    // Update hash table that maps from std::type_info to Python type
-    auto [it, success] =
-        internals.type_c2p.try_emplace(std::type_index(*t->type), to);
-    if (!success)
-        fail("nanobind::detail::nb_type_new(\"%s\"): type was already "
-             "registered!", t->name);
+    internals->type_c2p[std::type_index(*t->type)] = to;
 
     return result;
 }
 
 /// Encapsulates the implicit conversion part of nb_type_get()
 static NB_NOINLINE bool nb_type_get_implicit(PyObject *src,
                                              const std::type_info *cpp_type_src,
                                              const type_data *dst_type,
-                                             nb_internals &internals,
+                                             nb_type_map &type_c2p,
                                              cleanup_list *cleanup, void **out) noexcept {
     if (dst_type->implicit && cpp_type_src) {
         const std::type_info **it = dst_type->implicit;
         const std::type_info *v;
 
         while ((v = *it++)) {
             if (v == cpp_type_src || *v == *cpp_type_src)
                 goto found;
         }
 
         it = dst_type->implicit;
         while ((v = *it++)) {
-            auto it2 = internals.type_c2p.find(std::type_index(*v));
-            if (it2 != internals.type_c2p.end() &&
+            nb_type_map::iterator it2 = type_c2p.find(std::type_index(*v));
+            if (it2 != type_c2p.end() &&
                 PyType_IsSubtype(Py_TYPE(src), it2->second->type_py))
                 goto found;
         }
     }
 
     if (dst_type->implicit_py) {
         bool (**it)(PyTypeObject *, PyObject *, cleanup_list *) noexcept =
@@ -917,15 +919,15 @@
     if (result) {
         cleanup->append(result);
         *out = inst_ptr((nb_inst *) result);
         return true;
     } else {
         PyErr_Clear();
 
-        if (internals.print_implicit_cast_warnings) {
+        if (internals->print_implicit_cast_warnings) {
 #if !defined(Py_LIMITED_API)
             const char *name = Py_TYPE(src)->tp_name;
 #else
             PyObject *name_py = nb_inst_name(src);
             const char *name = PyUnicode_AsUTF8AndSize(name_py, nullptr);
 #endif
             // Can't use PyErr_Warn*() if conversion failed due to a stack overflow
@@ -950,68 +952,70 @@
                  cleanup_list *cleanup, void **out) noexcept {
     // Convert None -> nullptr
     if (src == Py_None) {
         *out = nullptr;
         return true;
     }
 
-    nb_internals &internals = internals_get();
     PyTypeObject *src_type = Py_TYPE(src);
     const std::type_info *cpp_type_src = nullptr;
     const bool src_is_nb_type = nb_type_check((PyObject *) src_type);
 
     type_data *dst_type = nullptr;
+    nb_type_map &type_c2p = internals->type_c2p;
 
     // If 'src' is a nanobind-bound type
     if (src_is_nb_type) {
         type_data *t = nb_type_data(src_type);
         cpp_type_src = t->type;
 
         // Check if the source / destination typeid are an exact match
         bool valid = cpp_type == cpp_type_src || *cpp_type == *cpp_type_src;
 
         // If not, look up the Python type and check the inheritance chain
         if (!valid) {
-            auto it = internals.type_c2p.find(std::type_index(*cpp_type));
-            if (it != internals.type_c2p.end()) {
+            auto it = type_c2p.find(std::type_index(*cpp_type));
+            if (it != type_c2p.end()) {
                 dst_type = it->second;
                 valid = PyType_IsSubtype(src_type, dst_type->type_py);
             }
         }
 
         // Success, return the pointer if the instance is correctly initialized
         if (valid) {
             nb_inst *inst = (nb_inst *) src;
 
-            if (!inst->ready &&
-                (flags & (uint8_t) cast_flags::construct) == 0) {
-                PyErr_WarnFormat(PyExc_RuntimeWarning, 1,
-                                 "nanobind: attempted to access an "
-                                 "uninitialized instance of type '%s'!\n",
-                                 t->name);
+            if (((flags & (uint8_t) cast_flags::construct) != 0) == inst->ready) {
+                PyErr_WarnFormat(
+                    PyExc_RuntimeWarning, 1, "nanobind: %s of type '%s'!\n",
+                    inst->ready
+                        ? "attempted to initialize an already-initialized "
+                          "instance"
+                        : "attempted to access an uninitialized instance",
+                    t->name);
                 return false;
             }
 
             *out = inst_ptr(inst);
 
             return true;
         }
     }
 
     // Try an implicit conversion as last resort (if possible & requested)
     if ((flags & (uint16_t) cast_flags::convert) && cleanup) {
         if (!src_is_nb_type) {
-            auto it = internals.type_c2p.find(std::type_index(*cpp_type));
-            if (it != internals.type_c2p.end())
+            auto it = type_c2p.find(std::type_index(*cpp_type));
+            if (it != type_c2p.end())
                 dst_type = it->second;
         }
 
         if (dst_type &&
             (dst_type->flags & (uint32_t) type_flags::has_implicit_conversions))
-            return nb_type_get_implicit(src, cpp_type_src, dst_type, internals,
+            return nb_type_get_implicit(src, cpp_type_src, dst_type, type_c2p,
                                         cleanup, out);
     }
 
     return false;
 }
 
 static PyObject *keep_alive_callback(PyObject *self, PyObject *const *args,
@@ -1031,15 +1035,15 @@
 
 void keep_alive(PyObject *nurse, PyObject *patient) {
     if (!patient || !nurse || nurse == Py_None || patient == Py_None)
         return;
 
     if (nb_type_check((PyObject *) Py_TYPE(nurse))) {
         nb_weakref_seq **pp =
-            (nb_weakref_seq **) &internals_get().keep_alive[nurse];
+            (nb_weakref_seq **) &internals->keep_alive[nurse];
 
         do {
             nb_weakref_seq *p = *pp;
             if (!p)
                 break;
             else if (p->payload == patient && !p->callback)
                 return;
@@ -1079,15 +1083,15 @@
 
 void keep_alive(PyObject *nurse, void *payload,
                 void (*callback)(void *) noexcept) noexcept {
     check(nurse, "nanobind::detail::keep_alive(): 'nurse' is undefined!");
 
     if (nb_type_check((PyObject *) Py_TYPE(nurse))) {
         nb_weakref_seq
-            **pp = (nb_weakref_seq **) &internals_get().keep_alive[nurse],
+            **pp = (nb_weakref_seq **) &internals->keep_alive[nurse],
             *s   = (nb_weakref_seq *) PyObject_Malloc(sizeof(nb_weakref_seq));
         check(s, "nanobind::detail::keep_alive(): out of memory!");
 
         s->payload = payload;
         s->callback = callback;
         s->next = *pp;
         *pp = s;
@@ -1190,17 +1194,16 @@
                       bool *is_new) noexcept {
     // Convert nullptr -> None
     if (!value) {
         Py_INCREF(Py_None);
         return Py_None;
     }
 
-    nb_internals &internals = internals_get();
-    nb_ptr_map &inst_c2p = internals.inst_c2p;
-    nb_type_map &type_map = internals.type_c2p;
+    nb_ptr_map &inst_c2p = internals->inst_c2p;
+    nb_type_map &type_map = internals->type_c2p;
     type_data *td = nullptr;
 
     auto lookup_type = [cpp_type, &td, &type_map]() -> bool {
         if (!td) {
             nb_type_map::iterator it =
                 type_map.find(std::type_index(*cpp_type));
 
@@ -1269,17 +1272,16 @@
     // Convert nullptr -> None
     if (!value) {
         Py_INCREF(Py_None);
         return Py_None;
     }
 
     // Check if the instance is already registered with nanobind
-    nb_internals &internals = internals_get();
-    nb_ptr_map &inst_c2p = internals.inst_c2p;
-    nb_type_map &type_map = internals.type_c2p;
+    nb_ptr_map &inst_c2p = internals->inst_c2p;
+    nb_type_map &type_map = internals->type_c2p;
 
     // Look up the corresponding Python type
     type_data *td = nullptr,
               *td_p = nullptr;
 
     auto lookup_type = [cpp_type, cpp_type_p, &td, &td_p, &type_map]() -> bool {
         if (!td) {
@@ -1442,35 +1444,30 @@
         inst->destruct = false;
     }
 
     inst->ready = false;
 }
 
 bool nb_type_isinstance(PyObject *o, const std::type_info *t) noexcept {
-    nb_internals &internals = internals_get();
-    auto it = internals.type_c2p.find(std::type_index(*t));
-    if (it == internals.type_c2p.end())
+    nb_type_map &type_c2p = internals->type_c2p;
+    auto it = type_c2p.find(std::type_index(*t));
+    if (it == type_c2p.end())
         return false;
     return PyType_IsSubtype(Py_TYPE(o), it->second->type_py);
 }
 
 PyObject *nb_type_lookup(const std::type_info *t) noexcept {
-    nb_internals &internals = internals_get();
-    auto it = internals.type_c2p.find(std::type_index(*t));
-    if (it != internals.type_c2p.end())
+    nb_type_map &type_c2p = internals->type_c2p;
+    auto it = type_c2p.find(std::type_index(*t));
+    if (it != type_c2p.end())
         return (PyObject *) it->second->type_py;
     return nullptr;
 }
 
-static PyTypeObject *nb_meta_cache = nullptr;
-
 bool nb_type_check(PyObject *t) noexcept {
-    if (NB_UNLIKELY(!nb_meta_cache))
-        nb_meta_cache = internals_get().nb_meta;
-
     PyTypeObject *meta  = Py_TYPE(t),
                  *meta2 = Py_TYPE((PyObject *) meta);
 
     return meta2 == nb_meta_cache;
 }
 
 size_t nb_type_size(PyObject *t) noexcept {
```

## nanobind/src/trampoline.cpp

```diff
@@ -11,75 +11,88 @@
 #include "nb_internals.h"
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 void trampoline_new(void **data, size_t size, void *ptr) noexcept {
     // GIL is held when the trampoline constructor runs
-    nb_ptr_map &inst_c2p = internals_get().inst_c2p;
+    nb_ptr_map &inst_c2p = internals->inst_c2p;
     nb_ptr_map::iterator it = inst_c2p.find(ptr);
     check(it != inst_c2p.end() && (((uintptr_t) it->second) & 1) == 0,
           "nanobind::detail::trampoline_new(): unique instance not found!");
 
     data[0] = it->second;
     memset(data + 1, 0, sizeof(void *) * 2 * size);
 }
 
 void trampoline_release(void **data, size_t size) noexcept {
     // GIL is held when the trampoline destructor runs
     for (size_t i = 0; i < size; ++i)
         Py_XDECREF((PyObject *) data[i*2 + 2]);
 }
 
-PyObject *trampoline_lookup(void **data, size_t size, const char *name,
-                            bool pure) {
+static void trampoline_enter_internal(void **data, size_t size,
+                                      const char *name, bool pure, ticket *t) {
     const PyObject *None = Py_None;
+    PyGILState_STATE state{ };
+    const char *error = nullptr;
+    PyObject *key = nullptr, *value = nullptr;
+    PyTypeObject *value_tp = nullptr;
+    size_t offset = 0;
 
-    current_method cm = current_method_data;
-    if (cm.self == data[0] && (cm.name == name || strcmp(cm.name, name) == 0)) {
-        if (pure)
-            raise("nanobind::detail::get_trampoline('%s()'): tried to call a "
-                  "pure virtual function!", name);
-        return nullptr;
-    }
-
-    // First quick sweep without lock
+    // First, perform a quick sweep without lock
     for (size_t i = 0; i < size; i++) {
         void *d_name  = data[2*i + 1],
              *d_value = data[2*i + 2];
-        if (name == d_name && d_value)
-            return d_value != None ? (PyObject *) d_value : nullptr;
+        if (name == d_name && d_value) {
+            if (d_value != None) {
+                t->state = PyGILState_Ensure();
+                t->key = (PyObject *) d_value;
+                return;
+            } else {
+                if (pure) {
+                    error = "tried to call a pure virtual function";
+                    state = PyGILState_Ensure();
+                    goto fail;
+                } else {
+                    return;
+                }
+            }
+        }
     }
 
-    PyGILState_STATE state = PyGILState_Ensure();
-
     // Nothing found -- retry, now with lock held
+    state = PyGILState_Ensure();
     for (size_t i = 0; i < size; i++) {
         void *d_name  = data[2*i + 1],
              *d_value = data[2*i + 2];
         if (name == d_name && d_value) {
-            PyGILState_Release(state);
-            return d_value != None ? (PyObject *) d_value : nullptr;
+            if (d_value != None) {
+                t->state = state;
+                t->key = (PyObject *) d_value;
+                return;
+            } else {
+                if (pure) {
+                    error = "tried to call a pure virtual function";
+                    goto fail;
+                } else {
+                    PyGILState_Release(state);
+                    return;
+                }
+            }
         }
     }
 
     // Sill no luck -- perform a lookup and populate the trampoline
-    const char *error = nullptr;
-    PyTypeObject *value_tp = nullptr;
-
-    size_t offset = 0;
     for (; offset < size; offset++) {
         if (data[2 * offset + 1] == nullptr &&
             data[2 * offset + 2] == nullptr)
             break;
     }
 
-    nb_internals &internals = internals_get();
-    PyObject *key = nullptr, *value = nullptr;
-
     if (offset == size) {
         error = "the trampoline ran out of slots (you will need to increase "
                 "the value provided to the NB_TRAMPOLINE() macro)";
         goto fail;
     }
 
     key = PyUnicode_InternFromString(name);
@@ -93,35 +106,73 @@
         error = "lookup failed";
         goto fail;
     }
 
     value_tp = Py_TYPE(value);
     Py_CLEAR(value);
 
-    if (value_tp == internals.nb_func || value_tp == internals.nb_method ||
-        value_tp == internals.nb_bound_method) {
+    if (value_tp == internals->nb_func || value_tp == internals->nb_method ||
+        value_tp == internals->nb_bound_method) {
+        Py_DECREF(key);
+
         if (pure) {
             error = "tried to call a pure virtual function";
             goto fail;
         }
 
-        Py_DECREF(key);
-        key = Py_None;
         Py_INCREF(Py_None);
+        key = Py_None;
     }
 
     data[2 * offset + 1] = (void *) name;
     data[2 * offset + 2] = key;
 
-    PyGILState_Release(state);
-    return key != None ? (PyObject *) key : nullptr;
+    if (key != None) {
+        t->state = state;
+        t->key = key;
+        return;
+    } else {
+        PyGILState_Release(state);
+        return;
+    }
 
 fail:
-    type_data *t = nb_type_data(Py_TYPE((PyObject *) data[0]));
+    type_data *td = nb_type_data(Py_TYPE((PyObject *) data[0]));
     PyGILState_Release(state);
 
     raise("nanobind::detail::get_trampoline('%s::%s()'): %s!",
-          t->name, name, error);
+          td->name, name, error);
+}
+
+NB_THREAD_LOCAL ticket *current_ticket = nullptr;
+
+void trampoline_enter(void **data, size_t size, const char *name, bool pure, ticket *t) {
+    trampoline_enter_internal(data, size, name, pure, t);
+
+    if (t->key) {
+        t->self = (PyObject *) data[0];
+        t->prev = current_ticket;
+
+        if (t->prev && t->prev->self.is(t->self) && t->prev->key.is(t->key)) {
+            t->self = handle();
+            t->key = handle();
+            t->prev = nullptr;
+            PyGILState_Release(t->state);
+            if (pure)
+                raise("nanobind::detail::get_trampoline('%s()'): tried to call "
+                      "a pure virtual function!", name);
+            return;
+        }
+
+        current_ticket = t;
+    }
+}
+
+void trampoline_leave(ticket *t) noexcept {
+    if (!t->key)
+        return;
+    current_ticket = t->prev;
+    PyGILState_Release(t->state);
 }
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## Comparing `nanobind-1.3.2.dist-info/LICENSE` & `nanobind-1.4.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `nanobind-1.3.2.dist-info/METADATA` & `nanobind-1.4.0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: nanobind
-Version: 1.3.2
+Version: 1.4.0
 Summary: nanobind: tiny and efficient C++/Python bindings
 Home-page: https://github.com/wjakob/nanobind
 Author: Wenzel Jakob
 Author-email: wenzel.jakob@epfl.ch
 License: BSD
 Description-Content-Type: text/markdown
 License-File: LICENSE
```

## Comparing `nanobind-1.3.2.dist-info/RECORD` & `nanobind-1.4.0.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-nanobind/__init__.py,sha256=gBlOi2MjedisgKOtYK2bg2UFHlsb44lsZGO2Vjypk-o,536
+nanobind/__init__.py,sha256=6vAxBQ2awAmp8v7upIOT7twSOuo7iIiD6FOHXBBQ1tg,536
 nanobind/__main__.py,sha256=pOZfAi6HXCHLnzBZ0Ax1jJ-PbFDYJ-XP51yG5AgTmjA,839
 nanobind/cmake/darwin-ld-cpython.sym,sha256=BlvfYcn-_krnQQZ_qF0APuKtsZke8jzoymkpxAK7hF0,21457
 nanobind/cmake/darwin-ld-pypy.sym,sha256=74TMJrfpAYZmXy6_TwCfDpZ6bNBJbegGl3oTR-Vy84Y,24614
-nanobind/cmake/nanobind-config.cmake,sha256=n5uGZUz55oYRzLhFuRq7BiwKgOgfZieLPySo8pz5Peg,10761
+nanobind/cmake/nanobind-config.cmake,sha256=C5ya3hmLVbTR93ILQ9tHFXFyeNOnB76MTrYUTd66how,11539
 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h,sha256=LJaMwboQYidGGoaldoAplZDcslLeT5sP6L8lZghVaDU,11776
 nanobind/ext/robin_map/include/tsl/robin_hash.h,sha256=9jsUsbV085jb736e5Z6MJIYUSvrwBpLYmagPsOTiglc,54550
 nanobind/ext/robin_map/include/tsl/robin_map.h,sha256=WQiZfe4hA3mzQLlJXDZQax0rWjctSnyJnB9jJJgeC6Y,28414
 nanobind/ext/robin_map/include/tsl/robin_set.h,sha256=m5o-74heDBBcvGNsGME8_Y4wiLMO8Ax8t70urBH6srk,23593
 nanobind/include/nanobind/make_iterator.h,sha256=WKcEOQc_L_Mhhk1GgwwvsysUTbSgiBCmDnm0X7K330o,5601
-nanobind/include/nanobind/nanobind.h,sha256=VJ5woVsVX9x19_BNzj3IhkjbqYa8eQW_XBNyi_RBVWs,1628
+nanobind/include/nanobind/nanobind.h,sha256=Ses-gspUfpCmJ9dydAC1l4rSO_MPNBT8c_iBMCSE4T8,1628
 nanobind/include/nanobind/nb_accessor.h,sha256=27K0E4cJYSBtD5VVsBtrLCWZTnTXXdr0IwtqLHeQ0aQ,5626
 nanobind/include/nanobind/nb_attr.h,sha256=FX-g3VwLt0DXn7D2YJSixGRPRsUFBgd1fw_OwD0VLW4,7387
 nanobind/include/nanobind/nb_call.h,sha256=kbJ6BL617m44XrkIY7kajFwBw59xcI8KGzGlgGDu0Bc,5533
 nanobind/include/nanobind/nb_cast.h,sha256=MYgPCQ_8wodwYLalnmklaNjnkJZYogL-o3p2BvEOjNI,14781
-nanobind/include/nanobind/nb_class.h,sha256=laD3sNLYkQ01d0_LI6u_XMTS31QOWVhgBDFpVDQ0whk,23845
-nanobind/include/nanobind/nb_defs.h,sha256=gK0JvSYf5qWm8joL4j04DphZTTtcFQk4mjZdfgOSUdE,5558
+nanobind/include/nanobind/nb_class.h,sha256=1EgUhbuz06cPRVYMrqXtWbkrI23u56BTGIf87N6WMXo,23613
+nanobind/include/nanobind/nb_defs.h,sha256=DIX45ECu-C62S2y4DzuVDS6qUdX6H6E05Omkk0HOb0g,5755
 nanobind/include/nanobind/nb_descr.h,sha256=tX2-_5kHTuIe62iGi0sqn-QehGNYGjcL32OmeWoYY2g,4129
 nanobind/include/nanobind/nb_enums.h,sha256=JSxGC4c2YyN83gmcTVV450KLJX_RTRPAHRPUhxuAvds,666
 nanobind/include/nanobind/nb_error.h,sha256=Akrj5ojzXHFA_EMXAHRhgfEWxINFkMEWzionhR7Rt3k,4168
 nanobind/include/nanobind/nb_func.h,sha256=fihjY5ofALSSyFul1XtRkXgfuPqMnAFr05FSjYZS9gQ,9769
-nanobind/include/nanobind/nb_lib.h,sha256=RvvqGKzRldZwG0mDJ7ZJNbsnAbO-88Q2lrlqD_JeQbw,18829
+nanobind/include/nanobind/nb_lib.h,sha256=y6dqmfwg0umRvR3D1CrNDXtTNgkHsxMoKpzlRsS8pSg,18946
 nanobind/include/nanobind/nb_misc.h,sha256=D9NdER_kwi7qHGgYtKTsjPKHIkZqcGpqG9wT9XMtT74,1167
 nanobind/include/nanobind/nb_python.h,sha256=tuHjb9Dd4X5MOILJdgOFN_7RBIAAq3Y1bL_-POIRqKU,1377
 nanobind/include/nanobind/nb_traits.h,sha256=NJAmlqi9G5fYtx2HiT0d9mcJpxsZPxDSfYFLvxemc20,6653
 nanobind/include/nanobind/nb_tuple.h,sha256=aqqTm9DkjH_SvDuPLKjU3Ya1lgs_LWyaQMkhTQRZoIc,2468
 nanobind/include/nanobind/nb_types.h,sha256=UKTEgkInNZS_bf4hEHf6UFPSxNGPg00-E0wwkdrON-8,25243
-nanobind/include/nanobind/ndarray.h,sha256=tZxkzVtWRCGHdjNQYijwBgGwDPFLs8mIp3AaQSdci-k,13478
+nanobind/include/nanobind/ndarray.h,sha256=-muLI4YV-Mi5fXaAlW02JqmnRizECYu3ubcCpT55qJM,13617
 nanobind/include/nanobind/operators.h,sha256=jSHKzNE_NDc--E65ycUsU6b0x1O_ThpzzCMV4uv5IE4,7449
-nanobind/include/nanobind/trampoline.h,sha256=w10Sw8RLAgjwvYPxjwuD14TWZ4jUN3RLP9rJCGIKgDE,2851
-nanobind/include/nanobind/eigen/dense.h,sha256=RfR8NHzMvkEfr7UxAwFukxLo1BwKz8IScZQekSYkj5E,8579
+nanobind/include/nanobind/trampoline.h,sha256=Mc81_m_s4pIlZkQEfeVjFfkJ7RZZ1e8T5XOVIPSwmuk,2976
+nanobind/include/nanobind/eigen/dense.h,sha256=mFs5jGmtS7bII-tJvmSwUCDeQvt5xWO8eo5S_-jXZlg,17102
 nanobind/include/nanobind/eigen/sparse.h,sha256=M1y9wF0AqVaIXXywzQVFtGZ91t5z8dytv_st5CxBhjg,6486
 nanobind/include/nanobind/stl/array.h,sha256=-jdVTy9gcqjH4kBVWbm52dGecHr90rwkusJX6ucHrII,535
-nanobind/include/nanobind/stl/bind_map.h,sha256=iEyY2r8iNdCYGY6_MHv6XsSzjWW_TY97ZQOBVflOo8w,5775
-nanobind/include/nanobind/stl/bind_vector.h,sha256=5z2IDbBMULnBdoJqRoQQFAWBwOPVhH40JVUqqZw8t9A,7250
+nanobind/include/nanobind/stl/bind_map.h,sha256=Lk3_TbUkqGiiUC6hQBCDIs26rB98z388FHHYQogktEg,5939
+nanobind/include/nanobind/stl/bind_vector.h,sha256=m8WMOgWlpS2656YnA1MyIDkABfDanXBd7NIQljwvBjU,7420
 nanobind/include/nanobind/stl/chrono.h,sha256=BAAn1ZoY3tJVqzWnIv7tNdd3qpz6NwMsH-XQDACCWyw,8675
 nanobind/include/nanobind/stl/filesystem.h,sha256=MAGHVOW5fq7GP3HwB-UaXDADA1kkPp1Y6JVe55XNFbk,2720
 nanobind/include/nanobind/stl/function.h,sha256=wlfxVQW3_c2KUJI9AFgq1MG9F9tXHJ8ASqjENy7CC3A,2478
 nanobind/include/nanobind/stl/list.h,sha256=6ZAtdW-epqSXkrXSEOl8fbutH36Eosd8qH2KrXSvIUk,527
 nanobind/include/nanobind/stl/map.h,sha256=1wxxFgt_oxW8zN-AMFPHhCQkaY5cZlA46x0wmKKoPLw,596
 nanobind/include/nanobind/stl/optional.h,sha256=Nb1jK2x46i2eFnPABiB4xSrm-_ML_3RSu95ehmwJ_O0,2281
 nanobind/include/nanobind/stl/pair.h,sha256=Xb4f3mmZAggKEk_Icq7zhlKDLOGuEuCHIX_VodrmizI,3403
@@ -53,23 +53,23 @@
 nanobind/include/nanobind/stl/detail/chrono.h,sha256=bT5XK6rf52kLrrNw9PwvrOsZqsJUEYLWp3lGG3HkCT8,10571
 nanobind/include/nanobind/stl/detail/nb_array.h,sha256=WAZNfoUYHGgDQwE6GJcmJ80zAhBpVX_JG6-EVeWHglo,1680
 nanobind/include/nanobind/stl/detail/nb_dict.h,sha256=SU18AkR6yw_nZGCXkU38f1GtIpXQE4QuuWPaFFQGcFA,2655
 nanobind/include/nanobind/stl/detail/nb_list.h,sha256=6WI8NOXhQRxqyUzr7hFVhUvhOQxmOL0t8TE5tTDOXt4,2132
 nanobind/include/nanobind/stl/detail/nb_set.h,sha256=vEq2LqjblYcgFHoC0VMptmTLq9-fH4SzY2ABNBZRNnM,1942
 nanobind/include/nanobind/stl/detail/traits.h,sha256=Aaa89qY0NJpmbkRzZA8OLLkH3IBZMV1aQ5Y1u9RUoaw,3218
 nanobind/src/buffer.h,sha256=Yk2RUt38GW4uFNAhhdhMbNGfakA0ike3twEzhEuEFDQ,4218
-nanobind/src/common.cpp,sha256=WJIH58sX_-h1NjlLLwezPTPAfwOYXechS6U0dN_Q7OI,28423
-nanobind/src/error.cpp,sha256=al-TrMRxd-6iu6uvqh8jpDC2OpRSRd1RsI4SrQKXClY,5671
-nanobind/src/implicit.cpp,sha256=r7IDxgu-sbzzL_WaNzGwEC3CnL8kHwOTNyaR0x3ZLQE,2548
+nanobind/src/common.cpp,sha256=n3idRyUuWCIgQzEUsld5QBRfyvsqcbz3KIzh6Re-UAE,28362
+nanobind/src/error.cpp,sha256=D4F6pAJF5bcqTx6ansIG5E2pQsrWJ-Tp8_0j5XvUZCk,5624
+nanobind/src/implicit.cpp,sha256=snqvYejHIbQazNgLFnszaFz1467P86R6X_caaHxrtwo,2538
 nanobind/src/nb_enum.cpp,sha256=vyQZjNi8o9RcUcFW1mIrFxuJbQQvAbf3-_3W-5thzvk,14696
-nanobind/src/nb_func.cpp,sha256=peRtcWsF7ejSouR2y6YXDiLmT5CUVrKr1d3w5ZJ8bCY,41402
-nanobind/src/nb_internals.cpp,sha256=ysc6IQ5PkJPQFCp6pH9pHQNBehaBDfW84dqljw-fKEk,14833
-nanobind/src/nb_internals.h,sha256=JIWsxZt9uiAQWvASdt-NOoNtWh1xDoFeY7YrNsN150s,10036
-nanobind/src/nb_ndarray.cpp,sha256=FaCBQPE7i_KmkXSP476WWzjo2dYVS7ZvlIhwvPZaAiY,21192
-nanobind/src/nb_static_property.cpp,sha256=6-vaicJEaSLm3KipTst_nVuAMW8ClgWSVUwFVpno7_M,2466
-nanobind/src/nb_type.cpp,sha256=Qrw3VGGH-jncPmYQJSdpjYjCrgNSDqN68e4NrN3IIM8,52907
-nanobind/src/trampoline.cpp,sha256=nZWDoYNYw19X7rr2c6Pk-2fJn4wJn6AVwR6cwcKSVec,3796
-nanobind-1.3.2.dist-info/LICENSE,sha256=8wUJGk5XgFhwsheijqSx8WYQ7s6EV9I3D4Iqlpa3WDY,1521
-nanobind-1.3.2.dist-info/METADATA,sha256=Xt_3KMg9Igt7eGoiZntl0R-f_XOv5_NYkhxJmQ_Vzhk,1406
-nanobind-1.3.2.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-nanobind-1.3.2.dist-info/top_level.txt,sha256=3pRezwhnZCbmPhzcbPKfaw-IRYTQ6WbLWu14UZgONhs,9
-nanobind-1.3.2.dist-info/RECORD,,
+nanobind/src/nb_func.cpp,sha256=skUxrLAZ3Syblbf4rJJ5qmrcjqV5KnQ9v2GQ2Wbe2hE,39358
+nanobind/src/nb_internals.cpp,sha256=rnme8IrrDPg77nBrwWF34hZMXMLbdpKiLq_ts1yc880,14972
+nanobind/src/nb_internals.h,sha256=b6dXAuQAaQYJfuMJwbgJBP-ajXR_2XcCT4m-WAAYUsU,9801
+nanobind/src/nb_ndarray.cpp,sha256=6eLbYh4NsBFcKA4ETao9hgIzzemgbFMkAL9RlTrtnio,21147
+nanobind/src/nb_static_property.cpp,sha256=CYmAYN1h9iXrFB7uXX7blMD5Q0doszQ_GuMhYX9SSws,2348
+nanobind/src/nb_type.cpp,sha256=RRPdK_Eyr4L8t0iIPc70dlEozvNTwUyFKFI1-nA4dso,52719
+nanobind/src/trampoline.cpp,sha256=kLn60AVuvoOALLeI-g6O7zGMk8ud0ZjG4H0gmmsn34A,5144
+nanobind-1.4.0.dist-info/LICENSE,sha256=8wUJGk5XgFhwsheijqSx8WYQ7s6EV9I3D4Iqlpa3WDY,1521
+nanobind-1.4.0.dist-info/METADATA,sha256=WF51CPVEX_SLF4Xpzu96fx2aBauaKHDsp2jL_v3siic,1406
+nanobind-1.4.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+nanobind-1.4.0.dist-info/top_level.txt,sha256=3pRezwhnZCbmPhzcbPKfaw-IRYTQ6WbLWu14UZgONhs,9
+nanobind-1.4.0.dist-info/RECORD,,
```

