# Comparing `tmp/cmtj-1.3.0-cp39-cp39-win_amd64.whl.zip` & `tmp/cmtj-1.3.1-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,26 @@
-Zip file size: 201407 bytes, number of entries: 21
--rw-rw-rw-  2.0 fat      530 b- defN 23-Jan-21 19:51 cmtj-1.3.0-py3.9-nspkg.pth
--rw-rw-rw-  2.0 fat   407040 b- defN 23-Jan-21 19:51 cmtj.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat        0 b- defN 23-Jan-21 19:50 cmtj/models/__init__.py
--rw-rw-rw-  2.0 fat     8550 b- defN 23-Jan-21 19:50 cmtj/models/domain_dynamics.py
--rw-rw-rw-  2.0 fat      357 b- defN 23-Jan-21 19:50 cmtj/models/drivers.py
--rw-rw-rw-  2.0 fat     8090 b- defN 23-Jan-21 19:50 cmtj/models/oersted.py
--rw-rw-rw-  2.0 fat    27423 b- defN 23-Jan-21 19:50 cmtj/models/sb.py
--rw-rw-rw-  2.0 fat      632 b- defN 23-Jan-21 19:50 cmtj/utils/__init__.py
--rw-rw-rw-  2.0 fat     2731 b- defN 23-Jan-21 19:50 cmtj/utils/energy.py
--rw-rw-rw-  2.0 fat     2494 b- defN 23-Jan-21 19:50 cmtj/utils/filters.py
--rw-rw-rw-  2.0 fat     4689 b- defN 23-Jan-21 19:50 cmtj/utils/linear.py
--rw-rw-rw-  2.0 fat     1608 b- defN 23-Jan-21 19:50 cmtj/utils/parallel.py
--rw-rw-rw-  2.0 fat    11387 b- defN 23-Jan-21 19:50 cmtj/utils/plotting.py
--rw-rw-rw-  2.0 fat     8877 b- defN 23-Jan-21 19:50 cmtj/utils/procedures.py
--rw-rw-rw-  2.0 fat     3404 b- defN 23-Jan-21 19:50 cmtj/utils/resistance.py
--rw-rw-rw-  2.0 fat    18431 b- defN 23-Jan-21 19:51 cmtj-1.3.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat      753 b- defN 23-Jan-21 19:51 cmtj-1.3.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-Jan-21 19:51 cmtj-1.3.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        5 b- defN 23-Jan-21 19:51 cmtj-1.3.0.dist-info/namespace_packages.txt
--rw-rw-rw-  2.0 fat        5 b- defN 23-Jan-21 19:51 cmtj-1.3.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1659 b- defN 23-Jan-21 19:51 cmtj-1.3.0.dist-info/RECORD
-21 files, 508765 bytes uncompressed, 198739 bytes compressed:  60.9%
+Zip file size: 212457 bytes, number of entries: 24
+-rw-rw-rw-  2.0 fat      530 b- defN 23-Jun-08 20:31 cmtj-1.3.1-py3.9-nspkg.pth
+-rw-rw-rw-  2.0 fat   418816 b- defN 23-Jun-08 20:31 cmtj.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-08 20:29 cmtj/models/__init__.py
+-rw-rw-rw-  2.0 fat    11410 b- defN 23-Jun-08 20:29 cmtj/models/domain_dynamics.py
+-rw-rw-rw-  2.0 fat      357 b- defN 23-Jun-08 20:29 cmtj/models/drivers.py
+-rw-rw-rw-  2.0 fat     1638 b- defN 23-Jun-08 20:29 cmtj/models/ensemble.py
+-rw-rw-rw-  2.0 fat    25252 b- defN 23-Jun-08 20:29 cmtj/models/general_sb.py
+-rw-rw-rw-  2.0 fat     8090 b- defN 23-Jun-08 20:29 cmtj/models/oersted.py
+-rw-rw-rw-  2.0 fat      739 b- defN 23-Jun-08 20:29 cmtj/utils/__init__.py
+-rw-rw-rw-  2.0 fat     2731 b- defN 23-Jun-08 20:29 cmtj/utils/energy.py
+-rw-rw-rw-  2.0 fat     2494 b- defN 23-Jun-08 20:29 cmtj/utils/filters.py
+-rw-rw-rw-  2.0 fat     3547 b- defN 23-Jun-08 20:29 cmtj/utils/general.py
+-rw-rw-rw-  2.0 fat     4689 b- defN 23-Jun-08 20:29 cmtj/utils/linear.py
+-rw-rw-rw-  2.0 fat     1608 b- defN 23-Jun-08 20:29 cmtj/utils/parallel.py
+-rw-rw-rw-  2.0 fat    11338 b- defN 23-Jun-08 20:29 cmtj/utils/plotting.py
+-rw-rw-rw-  2.0 fat    11263 b- defN 23-Jun-08 20:29 cmtj/utils/procedures.py
+-rw-rw-rw-  2.0 fat     3404 b- defN 23-Jun-08 20:29 cmtj/utils/resistance.py
+-rw-rw-rw-  2.0 fat     1427 b- defN 23-Jun-08 20:29 cmtj/utils/solvers.py
+-rw-rw-rw-  2.0 fat    18431 b- defN 23-Jun-08 20:31 cmtj-1.3.1.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1075 b- defN 23-Jun-08 20:31 cmtj-1.3.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 23-Jun-08 20:31 cmtj-1.3.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        5 b- defN 23-Jun-08 20:30 cmtj-1.3.1.dist-info/namespace_packages.txt
+-rw-rw-rw-  2.0 fat        5 b- defN 23-Jun-08 20:30 cmtj-1.3.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1906 b- defN 23-Jun-08 20:31 cmtj-1.3.1.dist-info/RECORD
+24 files, 530855 bytes uncompressed, 209415 bytes compressed:  60.6%
```

## zipnote {}

```diff
@@ -1,37 +1,43 @@
-Filename: cmtj-1.3.0-py3.9-nspkg.pth
+Filename: cmtj-1.3.1-py3.9-nspkg.pth
 Comment: 
 
 Filename: cmtj.cp39-win_amd64.pyd
 Comment: 
 
 Filename: cmtj/models/__init__.py
 Comment: 
 
 Filename: cmtj/models/domain_dynamics.py
 Comment: 
 
 Filename: cmtj/models/drivers.py
 Comment: 
 
-Filename: cmtj/models/oersted.py
+Filename: cmtj/models/ensemble.py
+Comment: 
+
+Filename: cmtj/models/general_sb.py
 Comment: 
 
-Filename: cmtj/models/sb.py
+Filename: cmtj/models/oersted.py
 Comment: 
 
 Filename: cmtj/utils/__init__.py
 Comment: 
 
 Filename: cmtj/utils/energy.py
 Comment: 
 
 Filename: cmtj/utils/filters.py
 Comment: 
 
+Filename: cmtj/utils/general.py
+Comment: 
+
 Filename: cmtj/utils/linear.py
 Comment: 
 
 Filename: cmtj/utils/parallel.py
 Comment: 
 
 Filename: cmtj/utils/plotting.py
@@ -39,26 +45,29 @@
 
 Filename: cmtj/utils/procedures.py
 Comment: 
 
 Filename: cmtj/utils/resistance.py
 Comment: 
 
-Filename: cmtj-1.3.0.dist-info/LICENSE
+Filename: cmtj/utils/solvers.py
+Comment: 
+
+Filename: cmtj-1.3.1.dist-info/LICENSE
 Comment: 
 
-Filename: cmtj-1.3.0.dist-info/METADATA
+Filename: cmtj-1.3.1.dist-info/METADATA
 Comment: 
 
-Filename: cmtj-1.3.0.dist-info/WHEEL
+Filename: cmtj-1.3.1.dist-info/WHEEL
 Comment: 
 
-Filename: cmtj-1.3.0.dist-info/namespace_packages.txt
+Filename: cmtj-1.3.1.dist-info/namespace_packages.txt
 Comment: 
 
-Filename: cmtj-1.3.0.dist-info/top_level.txt
+Filename: cmtj-1.3.1.dist-info/top_level.txt
 Comment: 
 
-Filename: cmtj-1.3.0.dist-info/RECORD
+Filename: cmtj-1.3.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cmtj/models/domain_dynamics.py

```diff
@@ -1,42 +1,54 @@
 import math
+from abc import ABC
 from collections import defaultdict
-from dataclasses import dataclass
-from typing import Callable
+from dataclasses import dataclass, field
+from typing import Callable, List, Literal
 
 from numba import njit
 from scipy.integrate import RK45
 
 from ..utils import bohr_magneton, echarge, gyromagnetic_ratio, hbar, mu0
-from .sb import VectorObj
+from ..utils.general import VectorObj
 
 gyro = gyromagnetic_ratio
 pi2 = math.pi / 2.
-"""
-Changing the DMI sign makes it an UP or DOWN domain wall (same chirality)
-"""
 
 
 class DW:
     """Initial conditions for the phi of DW equation."""
     NEEL_RIGHT = 0
     NEEL_LEFT = math.pi
     BLOCH_UP = math.pi / 2.
     BLOCH_DOWN = 3. * math.pi / 2.
 
 
+class DWRelax:
+    NO_RELAX = 0
+    STATIC = 1
+    DYNAMIC = 2
+
+
 @njit
 def get_pinning_field(X, Ms, pinning, Ly, Lz, V0_pin):
     arg = X * math.pi / pinning
     dVdx = 2 * math.pi * V0_pin * math.sin(arg) * math.cos(arg)
     denom = 2 * mu0 * Ms * Lz * Ly
     return -(1. / denom) * dVdx
 
 
 @njit
+def get_edge_field(X, Lx, V0_edge):
+    c = Lx / 2
+    arg = (X - (Lx / 2)) / c
+    p = 6
+    return -p * V0_edge * (math.sinh(arg) * math.cosh(arg)**(p - 1) / c)
+
+
+@njit
 def get_field_contribution(X, phi, hx, hy, hz, alpha, dw, Ms, V0_pin, pinning,
                            Ly, Lz):
 
     pinning = get_pinning_field(X,
                                 Ms=Ms,
                                 pinning=pinning,
                                 Ly=Ly,
@@ -46,184 +58,251 @@
         -hy * math.cos(phi) + hx * math.sin(phi))
     dphidt = gyro * (hz + pinning) + alpha * gyro * pi2 * (hy * math.cos(phi) -
                                                            hx * math.sin(phi))
     return dxdt, dphidt
 
 
 @njit
-def get_current_contributions(phi, bj, Hshe, je, alpha, beta, dw):
-    bjj = bj * je
-    Hshej = Hshe * je * math.cos(phi)
-    dxdt = (1 + alpha * beta) * bjj + alpha * gyro * dw * pi2 * Hshej
-    dphidt = (beta - alpha) * (bjj / dw) + gyro * pi2 * Hshej
-    return dxdt, dphidt
+def compute_gamma_a(X, phi, Q, dw, hk, hx, hy, hdmi, bj, IECterm):
+    pi2 = math.pi / 2.
+    fact_gamma = -0.5 * hk * math.sin(
+        2 * phi) - pi2 * hy * math.cos(phi) + pi2 * hx * math.sin(
+            phi) + Q * pi2 * hdmi * math.sin(phi) + IECterm
+    fact_stt = bj / dw
+    return gyro * fact_gamma + fact_stt
 
 
 @njit
-def compute_dynamics(X, phi, hx, hy, hz, alpha, dw, bj, beta, Hshe, je, Hdmi,
-                     Hk, Ms, V0_pin, pinning, Ly, Lz):
-    reduced_alpha = (1. + alpha**2)
-    ag = alpha * gyro
-    dg = dw * gyro * (math.pi / 2.)
-    field_contr = get_field_contribution(X,
-                                         phi,
-                                         hx=hx,
-                                         hy=hy,
-                                         hz=hz,
-                                         alpha=alpha,
-                                         dw=dw,
-                                         Ms=Ms,
-                                         V0_pin=V0_pin,
-                                         pinning=pinning,
-                                         Ly=Ly,
-                                         Lz=Lz)
-    j_contr = get_current_contributions(phi,
-                                        bj=bj,
-                                        Hshe=Hshe,
-                                        je=je,
-                                        alpha=alpha,
-                                        beta=beta,
-                                        dw=dw)
-    dXdt = -gyro * dw * (Hk / 2.) * math.sin(
-        2 * phi) + dg * Hdmi * math.sin(phi) + field_contr[0] + j_contr[0]
-
-    dPhidt = ag * (Hk / 2.) * math.sin(2 * phi) - ag * pi2 * Hdmi * math.sin(
-        phi) + field_contr[1] + j_contr[1]
+def compute_gamma_b(X, phi, Q, dw, hshe, hz, hr, beta, bj, Ms, Lx, Ly, Lz,
+                    V0_pin, V0_edge, pinning):
+    pi2 = math.pi / 2
+    hp = get_pinning_field(X,
+                           Ms=Ms,
+                           pinning=pinning,
+                           Ly=Ly,
+                           Lz=Lz,
+                           V0_pin=V0_pin)
+    he = get_edge_field(X, Lx, V0_edge)
+    fact_gamma = Q * (he + hz + hp + pi2 * hshe *
+                      math.cos(phi)) - beta * pi2 * hr * math.cos(phi)
+    fact_stt = beta * bj / dw
+    return gyro * fact_gamma + fact_stt
 
-    dXdt = dXdt / reduced_alpha
-    dPhidt = dPhidt / reduced_alpha
 
-    return dXdt, dPhidt
+@njit
+def compute_dynamics(X, phi, delta, alpha, Q, hx, hy, hz, hk, hdmi, hr, hshe,
+                     beta, bj, Ms, Lx, Ly, Lz, V0_pin, V0_edge, pinning,
+                     IECterm, thickness, A, Ku, Kp):
+    gamma_a = compute_gamma_a(X, phi, Q, delta, hk, hx, hy, hdmi, bj, IECterm)
+    gamma_b = compute_gamma_b(X, phi, Q, delta, hshe, hz, hr, beta, bj, Ms, Lx,
+                              Ly, Lz, V0_pin, V0_edge, pinning)
+    dXdt = delta * (gamma_a + alpha * gamma_b)
+    dPhidt = -alpha * gamma_a + gamma_b
+    pref = gyro / (alpha * mu0 * Ms * thickness)
+    # domain width relaxation from Thiaville
+    dDeltadt = pref * (A / delta - delta * (Ku + Kp * math.sin(phi)**2))
+    # dDeltadt  = 0
+    return dXdt, dPhidt, dDeltadt
 
 
 @dataclass
 class DomainWallDynamics:
     """Domain Wall dynamics class.
-    :param alpha: Gilbert damping.
-    :param domain_width: width of the domain.
     :param H: applied magnetic field vector.
-    :param Hk: anisotropy field [A/m].
+    :param alpha: Gilbert damping.
     :param Ms: magnetisation saturation [A/m].
     :param thickness: thickness of the FM material.
     :param SHE_angle: Spin Hall Effect angle.
     :param D: DMI constant.
+    :param Ku: perpendicular anisotropy constant.
+    :param Kp: inplane anisotropy constant.
+    :param A: exchange constant.
     :param beta: STT beta parameter.
     :param p: STT polarisation efficiency.
     :param V0_pin: pinning voltage constant.
+    :param V0_edge: edge voltage constant.
     :param pinning: the pinning period.
-    :param Lz: z-dimension of the FM block.
+    :param Lx: z-dimension of the FM block.
     :param Ly: y-dimension of the FM block.
-    :param relativistic: whether to include relativistic effects?
-    :param vmax_magnon: m/s, max magnon velocity => 2A/Sd
-                        A -- exchange constant.
-                        S -- |S1| + |S2| = total spin density of sublattices.
-                        d -- interatomic distance.
-
+    :param Lz: z-dimension of the FM block.
+    :param Q: up-down or down-up wall parameter (either 1 or -1).
+    :param Hr: Rashba field [A/m].
+    :param moving_field: whether the anisotropy field is perpendicular or parallel
+    :param relax_dw: whether to relax the domain width. See DWRelax class.
     For classical formulation see:
     Current-driven dynamics of chiral ferromagnetic domain walls, Emori et al, 2013
-
-    For relativisitc formulation see:
-    Relativistic kinematics of a magnetic soliton, Caretta et al., 2020
     """
-    alpha: float
-    domain_width: float
     H: VectorObj
-    Hk: float
+    alpha: float
     Ms: float
     thickness: float
     SHE_angle: float
     D: float
+    Ku: float  # The out-of-plane anisotropy constant
+    Kp: float  # The in-plane anisotropy constant
+    A: float = 1e-11  # J/m
     beta: float = 1
     p: float = 1
     V0_pin: float = 1.65e-20
+    V0_edge: float = 0
     pinning: float = 30e-9
-    Lz: float = 3e-9
+    Lx: float = 120e-9
     Ly: float = 120e-9
-    relativistic: bool = False
-    vmax_magnon: float = 5000  # m/s, max magnon velocity => 2A/Sd
+    Lz: float = 3e-9
+    Q: int = 1
+    Hr: float = 0
+    moving_field: Literal["perpendicular", "inplane"] = "perpendicular"
+    relax_dw: DWRelax = DWRelax.STATIC
+    dw0: float = field(init=False)
 
     def __post_init__(self):
-        self.dw = self.domain_width
-        self.dw_hat = self.dw
+        # in post init we already have p
+        self.bj = bohr_magneton * self.p / (echarge * self.Ms)
+        self.je_driver = lambda t: 0
         denom = (2 * self.Ms * mu0 * echarge * self.thickness)
         self.Hshe = hbar * self.SHE_angle / denom
-        self.Hdmi = self.D / (mu0 * self.Ms * self.dw)
-
-        self.bj = bohr_magneton * self.p / (echarge * self.Ms)
         self.hx, self.hy, self.hz = self.H.get_cartesian()
-        self.je_driver = lambda t: 0
+        self.dw0 = self.get_unrelaxed_domain_width()
+
+        if self.moving_field == "perpendicular":
+            self.Hk = self.get_perpendicular_anisotropy_field()
+        elif self.moving_field == "inplane":
+            self.Hk = self.get_inplane_anisotropy_field()
+
+    def get_unrelaxed_domain_width(self, effective=False):
+        """Domain width is based off the effective perpendicular anisotropy.
+        We reduce the perpendicular anisotropy by demagnetising field"""
+        # Keff = self.Ku - 0.5*mu0*(self.Ms)**2
+        if effective:
+            Keff = self.Ku - (0.5 * mu0) * (self.Ms**2)
+        else:
+            Keff = self.Ku
+        return math.sqrt(self.A / Keff)
 
     def set_current_function(self, driver: Callable):
         """
         :param driver: A function of time that returns the current density
         """
         self.je_driver = driver
 
-    def thiaville_llg(self, t, vec):
+    def get_Hdmi(self, domain_width):
+        """Returns the DMI field"""
+        return self.D / (mu0 * self.Ms * domain_width)
+
+    def get_perpendicular_anisotropy_field(self):
+        """Returns the perpeanisotropy field"""
+        return 2 * self.Ku / (mu0 * self.Ms)
+
+    def get_inplane_anisotropy_field(self):
+        """Returns the in-plane anisotropy field"""
+        return 2 * self.Kp / (mu0 * self.Ms)
+
+
+@dataclass
+class MultilayerWallDynamics:
+    layers: List[DomainWallDynamics]
+    J: float = 0
+    vector_size: int = 3  # 3 for X, phi, delta
+
+    def __post_init__(self):
+        if len(self.layers) > 2:
+            raise ValueError("Wall dynamics supported up to 2 layers")
+
+    def multilayer_dw_llg(self, t, vec):
         """Solve the Thiaville llg equation for LLG.
         :param t: current simulation time.
-        :param vec: contains [X, phi], current DW position and its chirality.
-        :returns (dXdt, dPhidt): velocity and change of chirality.
+        :param vec: contains [X, phi, delta], current DW position, its angle and domain width.
+        :returns (dXdt, dPhidt, dDeltad): velocity and change of angle and domain width.
         """
-        X, phi = vec
-        je_at_t = self.je_driver(t=t)
-
-        dXdt, dPhidt = compute_dynamics(X,
-                                        phi,
-                                        hx=self.hx,
-                                        hy=self.hy,
-                                        hz=self.hz,
-                                        alpha=self.alpha,
-                                        dw=self.dw_hat,
-                                        bj=self.bj,
-                                        beta=self.beta,
-                                        Hshe=self.Hshe,
-                                        je=je_at_t,
-                                        Hdmi=self.Hdmi,
-                                        Hk=self.Hk,
-                                        Ms=self.Ms,
-                                        V0_pin=self.V0_pin,
-                                        pinning=self.pinning,
-                                        Lz=self.Lz,
-                                        Ly=self.Ly)
-        if self.relativistic:
-            # contract the domain wall width
-            lorentz_factor = 1 / math.sqrt(1 - (self.vmax_magnon / dXdt)**2)
-            self.dw_hat = self.dw / lorentz_factor
-            self.Hdmi = self.D / (mu0 * self.Ms * self.dw_hat)
-
-        return dXdt, dPhidt
+        # vector is X1, phi1, Delta1, X2, phi2, Delta2...
+        layer: DomainWallDynamics
+        new_vec = []
+        for i, layer in enumerate(self.layers):
+            je_at_t = layer.je_driver(t=t)
+            reduced_alpha = (1. + layer.alpha**2)
+            lx = vec[self.vector_size * i]
+            lphi = vec[(self.vector_size * i) + 1]
+            ldomain_width = vec[(self.vector_size * i) + 2]
+            if len(self.layers) == 1:
+                Jterm = 0
+            else:
+                Jterm = 2 * self.J / (layer.Ms * mu0 * layer.thickness)
+                otherphi = vec[self.vector_size * (i - 1) + 1]
+                Jterm *= math.sin(lphi - otherphi)
+
+            hdmi = layer.get_Hdmi(ldomain_width)
+            dXdt, dPhidt, dDeltadt = compute_dynamics(
+                X=lx,
+                phi=lphi,
+                delta=ldomain_width,
+                Q=layer.Q,
+                hx=layer.hx,
+                hy=layer.hy,
+                hz=layer.hz,
+                alpha=layer.alpha,
+                bj=layer.bj * je_at_t,
+                hr=layer.Hr,
+                beta=layer.beta,
+                hshe=layer.Hshe * je_at_t,
+                hdmi=hdmi,
+                hk=layer.Hk,
+                Ms=layer.Ms,
+                IECterm=Jterm,
+                V0_pin=layer.V0_pin,
+                V0_edge=layer.V0_edge,
+                pinning=layer.pinning,
+                Lx=layer.Lx,
+                Ly=layer.Ly,
+                Lz=layer.Lz,
+                A=layer.A,
+                Ku=layer.Ku,
+                Kp=layer.Kp,
+                thickness=layer.thickness)
+            dXdt = dXdt / reduced_alpha
+            dPhidt = dPhidt / reduced_alpha
+            if layer.relax_dw != DWRelax.DYNAMIC:
+                dDeltadt = 0  # no relaxation in the ODE
+            new_vec.extend([dXdt, dPhidt, dDeltadt])
+        return new_vec
 
     def run(self,
             sim_time: float,
-            x0: float = 0,
-            phi0: float = 0,
-            max_step=1e-10):
-        """Run simulation of DW dynamics
+            starting_conditions: List[float],
+            max_step: float = 1e-10):
+        """Run simulation of DW dynamics.
         :param sim_time: total simulation time (simulation units).
-        :param x0: starting position of the DW.
-        :param phi0: starting chiral angle of the DW.
+        :param starting_conditions: starting position and angle of the DW.
         :param max_step: maximum allowed step of the RK45 method.
         """
-        integrator = RK45(fun=self.thiaville_llg,
+        integrator = RK45(fun=self.multilayer_dw_llg,
                           t0=0.,
                           first_step=1e-16,
                           max_step=max_step,
-                          y0=[x0, phi0],
+                          y0=starting_conditions,
                           rtol=1e-12,
                           t_bound=sim_time)
         result = defaultdict(list)
         while True:
             integrator.step()
-            x, phi = integrator.y
-            vel = (x - integrator.y_old[0]) / integrator.step_size
-            result['t'].append(integrator.t)
-            result['v'].append(vel)
-            result['x'].append(x)
-            result['phi'].append(phi)
             if integrator.status == 'failed':
                 print("Failed to converge")
                 break
+            layer_vecs = integrator.y
+            result['t'].append(integrator.t)
+            for i, layer in enumerate(self.layers):
+                x, phi, dw = layer_vecs[self.vector_size * i], layer_vecs[
+                    self.vector_size * i +
+                    1], layer_vecs[self.vector_size * i + 2]
+                # static relaxation Thiaville
+                if layer.relax_dw == DWRelax.STATIC:
+                    ratio = layer.Kp / layer.Ku
+                    dw = layer.dw0 / math.sqrt(1 + ratio * math.sin(phi)**2)
+                vel = (x - integrator.y_old[2 * i]) / integrator.step_size
+                result[f'dw_{i}'].append(dw)
+                result[f'v_{i}'].append(vel)
+                result[f'x_{i}'].append(x)
+                result[f'phi_{i}'].append(phi)
+                result[f'je_{i}'].append(layer.je_driver(t=integrator.t))
             if integrator.status == 'finished':
                 break
 
         return result
```

## cmtj/utils/__init__.py

```diff
@@ -1,10 +1,11 @@
 import math
 
 from .filters import Filters
+from .general import VectorObj, box_muller_random, perturb_position
 from .linear import FieldScan
 from .resistance import *
 
 # constants
 OetoAm = 79.57747
 AmtoOe = 1.0 / OetoAm
 TtoAm = 795774.715459
@@ -16,15 +17,12 @@
 gyromagnetic_ratio = 2.211e5
 gamma = 28024e6
 gamma_rad = 1.76e11
 me = 9.109e-31
 bohr_magneton = echarge * hbar / (2 * me)
 
 __all__ = [
-    "Filters",
-    "FieldScan",
-    "compute_sd",
-    "compute_resistance",
-    "calculate_magnetoresistance",
-    "calculate_resistance_series",
-    "calculate_resistance_parallel",
+    "Filters", "FieldScan", "compute_sd", "compute_resistance",
+    "calculate_magnetoresistance", "calculate_resistance_series",
+    "calculate_resistance_parallel", "VectorObj", "box_muller_random",
+    "perturb_position"
 ]
```

## cmtj/utils/linear.py

```diff
@@ -91,15 +91,15 @@
     def theta_scan(start: float, stop: float, steps: int, amplitude: float,
                    phi: float) -> Tuple[np.ndarray, np.ndarray]:
         """
         Compute a linear theta angle sweep. Angles given in deg.
         :param start: polar angle start of the sweep
         :param stop: polar angle end of the sweep
         :param steps: number of steps
-        :param magnitude: magnitude of the scanned field.
+        :param amplitude: amplitude of the scanned field.
         :param phi: azimuthal angle in deg.
         """
         theta_span = np.linspace(start, stop, endpoint=True, num=steps)
         st, ct, sp, cp = FieldScan._trig_compute(theta_span, phi)
         Hx = st * cp * amplitude
         Hy = st * sp * amplitude
         Hz = ct * amplitude
@@ -109,15 +109,15 @@
     def phi_scan(start: float, stop: float, steps: int, amplitude: float,
                  theta: float) -> Tuple[np.ndarray, np.ndarray]:
         """
         Compute a linear phi angle sweep. Angles given in deg.
         :param start: azimuthal angle start of the sweep
         :param stop: azimuthal angle end of the sweep
         :param steps: number of steps
-        :param magnitude: magnitude of the scanned field
+        :param amplitude: amplitude of the scanned field
         :param theta: polar angle in deg.
         """
         phi_span = np.linspace(start, stop, endpoint=True, num=steps)
         st, ct, sp, cp = FieldScan._trig_compute(theta, phi_span)
         Hx = st * cp * amplitude
         Hy = st * sp * amplitude
         Hz = ct * amplitude * np.ones_like(Hy)
```

## cmtj/utils/plotting.py

```diff
@@ -66,15 +66,14 @@
     """Plot a coloured trajectory in 3D. Normalises to unit sphere.
     Colour of the trajectory now designates the flow of time.
     :param ax: matplotlib axis
     :param x: x-coordinates
     :param y: y-coordinates
     :param z: z-coordinates
     :param colormap: colormap to use
-    :param alpha: alpha value of the trajectory
     """
     xs, ys, zs = get_sphere()
     m = np.asarray([x, y, z])
     points = m.T.reshape(-1, 1, 3)
     segs = np.concatenate([points[:-1], points[1:]], axis=1)
     colors = sns.color_palette(colormap, len(segs))
     if ax is None:
```

## cmtj/utils/procedures.py

```diff
@@ -3,15 +3,16 @@
 from dataclasses import dataclass
 from typing import Any, Dict, List, Tuple
 
 import numpy as np
 from scipy.fft import fft, fftfreq
 from tqdm import tqdm
 
-from cmtj import AxialDriver, Axis, Junction, NullDriver, ScalarDriver
+from cmtj import AxialDriver, Axis, CVector, Junction, NullDriver, ScalarDriver
+from cmtj.utils.filters import Filters
 
 from .resistance import calculate_resistance_series, compute_sd
 
 
 @dataclass
 class ResistanceParameters:
     """A data holder for resistance parameters. Not all have to be filled"""
@@ -22,45 +23,64 @@
     Rahe: float = 0
     Rsmr: float = 0
     Ramr: float = 0
     w: float = 0  # width
     l: float = 0  # length
 
 
+def compute_spectrum_strip(input_m: np.ndarray, int_step: float,
+                           max_frequency: float):
+    yf = np.abs(fft(input_m))
+    freqs = fftfreq(len(yf), int_step)
+    freqs = freqs[:len(freqs) // 2]
+    yf = yf[:len(yf) // 2]
+
+    findx = np.argwhere(freqs <= max_frequency)
+    freqs = freqs[findx]
+    yf = yf[findx]
+
+    return yf, freqs
+
+
 def PIMM_procedure(
     junction: 'Junction',
     Hvecs: np.ndarray,
     int_step: float,
     resistance_params: List[ResistanceParameters],
     Hoe_direction: Axis = Axis.zaxis,
     Hoe_excitation: float = 50,
     Hoe_duration: int = 3,
     simulation_duration: float = 5e-9,
+    wait_time: float = 0e-9,
     max_frequency: float = 80e9,
-    output_full_trajectories: bool = False
+    disturbance: float = 1e-3,
+    full_output: bool = False
 ) -> Tuple[np.ndarray, np.ndarray, Dict[str, Any]]:
     """Procedure for computing Pulse Induced Microwave Magnetometry
     :param junction: junction to be simulated.
     :param Hvecs: list of cartesian vectors. (use FieldScan.amplitude_scan or alike)
     :param int_step: integration step [s].
     :param resistance_params: list of resistance parameters.
     :param Hoe_direction: direction of oersted field (x, y or z).
     :param simulation_duration: duration of simulation [s].
-    :param Hoe_excitation: excitation amplitude of Hoe [A/m].
+    :param wait_time: time to wait before taking vector for the fft [s].
     :param Hoe_duration: duration of Hoe excitation in multiples of in step
     :param max_frequency: maximum frequency -- larger will be dropped [Hz].
-    :param output_full_trajectories: if True, return the full trajectories of the magnets.
+    :param disturbance: disturbance to be applied to the magnetization (std of normal distribution).
+    :param full_output: if True, return the full trajectories and per layer spectra.
     :return: (spectrum, frequencies, other_data)
     other_data is a dictionary with the following keys:
     - 'H': Hext field [A/m]
     - 'Rx': resistance in x direction [Ohm]
     - 'Ry': resistance in y direction [Ohm]
     - 'm_avg': average magnetization [unit]
     - 'm_traj': magnetization trajectories [unit]
     """
+    if wait_time > simulation_duration:
+        raise ValueError("wait_time must be smaller than simulation_duration!")
     spectrum = []
     extraction_m_component = None
     if Hoe_direction == Axis.zaxis:
         extraction_m_component = 'z'
         oedriver = AxialDriver(
             NullDriver(), NullDriver(),
             ScalarDriver.getStepDriver(0, Hoe_excitation, 0,
@@ -77,45 +97,51 @@
             ScalarDriver.getStepDriver(0, Hoe_excitation, 0,
                                        int_step * Hoe_duration), NullDriver(),
             NullDriver())
 
     # get layer strings
     layer_ids = junction.getLayerIds()
     output = defaultdict(list)
+    normalising_factor = np.sum(
+        [layer.thickness * layer.Ms for layer in junction.layers])
     for H in tqdm(Hvecs, desc="Computing PIMM"):
         junction.clearLog()
         junction.setLayerExternalFieldDriver(
             "all",
             AxialDriver(ScalarDriver.getConstantDriver(H[0]),
                         ScalarDriver.getConstantDriver(H[1]),
                         ScalarDriver.getConstantDriver(H[2])))
         junction.setLayerOerstedFieldDriver("all", oedriver)
-
+        if disturbance:
+            for layer_id in layer_ids:
+                old_mag = junction.getLayerMagnetisation(layer_id)
+                new_mag = CVector(old_mag.x + np.random.normal(0, disturbance),
+                                  old_mag.y + np.random.normal(0, disturbance),
+                                  old_mag.z + np.random.normal(0, disturbance))
+                new_mag.normalize()
+                junction.setLayerMagnetisation(layer_id, new_mag)
         junction.runSimulation(simulation_duration, int_step, int_step)
         log = junction.getLog()
-
-        m_traj = np.asarray([[
-            log[f'{layer_ids[i]}_mx'], log[f'{layer_ids[i]}_my'],
-            log[f'{layer_ids[i]}_mz']
-        ] for i in range(len(layer_ids))])
-        m = m_traj[:, :, -100:]  # all layers, all x, y, z, last timestamp
-        m_avg = np.mean(m_traj[:, :, -1], 0)
-        mixed = [
-            np.asarray(log[f"{layer_ids[i]}_m{extraction_m_component}"])
-            for i in range(len(layer_ids))
-        ]
-        mixed = np.mean(np.squeeze(mixed), axis=0)
-        yf = np.abs(fft(mixed))
-        freqs = fftfreq(len(yf), int_step)
-        freqs = freqs[:len(freqs) // 2]
-        yf = yf[:len(yf) // 2]
-
-        findx = np.argwhere(freqs <= max_frequency)
-        freqs = freqs[findx]
-        yf = yf[findx]
+        indx = np.argwhere(np.asarray(log['time']) >= wait_time).ravel()
+        m_traj = np.asarray([
+            np.asarray([
+                log[f'{layer.id}_mx'], log[f'{layer.id}_my'],
+                log[f'{layer.id}_mz']
+            ]) * layer.thickness * layer.Ms / normalising_factor
+            for layer in junction.layers
+        ])
+        m = m_traj[:, :, -100:]  # all layers, all x, y, z, last 100 steps
+        mixed = np.asarray([
+            np.asarray(log[f"{layer.id}_m{extraction_m_component}"])[indx] *
+            layer.thickness * layer.Ms / normalising_factor
+            for layer in junction.layers
+        ])
+        mixed = np.squeeze(mixed)
+        mixed_sum = mixed.sum(axis=0)
+        yf, freqs = compute_spectrum_strip(mixed_sum, int_step, max_frequency)
 
         spectrum.append(yf)
         Rx, Ry = calculate_resistance_series(
             [r.Rxx0
              for r in resistance_params], [r.Rxy0 for r in resistance_params],
             [r.Ramr
              for r in resistance_params], [r.Rahe for r in resistance_params],
@@ -123,39 +149,49 @@
             m,
             l=[r.l for r in resistance_params],
             w=[r.w for r in resistance_params])
         # fill the output dict
         output['H'].append(H)
         output['Rx'].append(Rx)
         output['Ry'].append(Ry)
-        output['m_avg'].append(m_avg)
-        if output_full_trajectories:
+        output['m_avg'].append(m_traj[:, :, -1].sum(0))
+        if full_output:
             output['m_traj'].append(m_traj)
+            for li, layer_id in enumerate(layer_ids):
+                y, _ = compute_spectrum_strip(mixed[li], int_step,
+                                              max_frequency)
+                output[layer_id].append(y)
     spectrum = np.squeeze(np.asarray(spectrum))
+    if full_output:
+        for layer_id in layer_ids:
+            output[layer_id] = np.asarray(output[layer_id]).squeeze()
     return spectrum, freqs, output
 
 
 def VSD_procedure(junction: Junction,
                   Hvecs: np.ndarray,
                   frequencies: np.ndarray,
                   int_step: float,
                   resistance_params,
                   Hoe_direction: Axis = Axis.yaxis,
                   Hoe_excitation: float = 50,
                   simulation_duration: float = 30e-9,
+                  disturbance: float = 1e-3,
                   Rtype: str = 'Rz'):
-    """Procedure for computing Voltage-Spin Diode
+    """Procedure for computing Voltage-Spin Diode.
+    We use the Oersted field sine exctitation to excite the system.
     :param junction: junction to be simulated.
     :param Hvecs: list of cartesian vectors. (use FieldScan.amplitude_scan or alike)
     :param frequencies: list of frequencies [Hz].
     :param int_step: integration step [s].
     :param resistance_params: list of resistance parameters.
     :param Hoe_direction: direction of oersted field (x, y or z).
     :param Hoe_excitation: excitation amplitude of Hoe [A/m].
     :param simulation_duration: duration of simulation [s].
+    :param disturbance: disturbance to be applied to the magnetization (std of normal distribution).
     :param Rtype: type of resistance to be used. (Rx Ry or Rz)
     """
     layer_ids = junction.getLayerIds()
 
     def simulate_VSD(H: np.ndarray, frequency: float, resistance_params):
 
         if Hoe_direction == Axis.zaxis:
@@ -175,14 +211,22 @@
         junction.clearLog()
         junction.setLayerExternalFieldDriver(
             "all",
             AxialDriver(ScalarDriver.getConstantDriver(H[0]),
                         ScalarDriver.getConstantDriver(H[1]),
                         ScalarDriver.getConstantDriver(H[2])))
         junction.setLayerOerstedFieldDriver("all", oedriver)
+        if disturbance:
+            for layer_id in layer_ids:
+                old_mag = junction.getLayerMagnetisation(layer_id)
+                new_mag = CVector(old_mag.x + np.random.normal(0, disturbance),
+                                  old_mag.y + np.random.normal(0, disturbance),
+                                  old_mag.z + np.random.normal(0, disturbance))
+                new_mag.normalize()
+                junction.setLayerMagnetisation(layer_id, new_mag)
         junction.runSimulation(simulation_duration, int_step, int_step)
         log = junction.getLog()
         m_traj = np.asarray([[
             log[f'{layer_ids[i]}_mx'], log[f'{layer_ids[i]}_my'],
             log[f'{layer_ids[i]}_mz']
         ] for i in range(len(layer_ids))])
         if Rtype == 'Rz':
```

## Comparing `cmtj-1.3.0-py3.9-nspkg.pth` & `cmtj-1.3.1-py3.9-nspkg.pth`

 * *Files identical despite different names*

## Comparing `cmtj-1.3.0.dist-info/LICENSE` & `cmtj-1.3.1.dist-info/LICENSE`

 * *Files identical despite different names*

